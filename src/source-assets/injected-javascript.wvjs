// Prevent restoring the last-scrolled position from a previous session.
history.scrollRestoration = 'manual';

{
  // Insert a viewport meta tag
  const meta = document.createElement('meta');
  meta.name = 'viewport';
  meta.content = 'width=device-width, initial-scale=1, user-scalable=no';
  document.head.appendChild(meta);
}

// Although <rb> is a deprecated element, on WebKit, the CSS Custom Highlight
// API simply doesn't highlight the bare text nodes, so we apply this change as
// a workaround.
wrapRubyBaseTextsWithRb(document.body);

/**
 * @param {object} obj
 * @param {Array<import("../../utils/look-up-term").LookupResult>} [obj.results]
 * @param {Range} obj.tokenRange
 */
function updatePopover({ results, tokenRange }) {
  /**
   * We use <dialog> rather than popover mainly because light dismissal is even
   * more broken in Safari 18 for popovers than it is for dialogs.
   * @type {HTMLDialogElement}
   */
  const popover =
    document.getElementById('paranovel-popover') ??
    document.createElement('div');
  const popoverStage =
    document.getElementById('paranovel-popover-stage') ??
    document.createElement('div');
  const popoverContent =
    document.getElementById('paranovel-popover-content') ??
    document.createElement('div');
  const anchor =
    document.getElementById('paranovel-anchor') ??
    document.createElement('div');
  popover.id = 'paranovel-popover';
  popoverStage.id = 'paranovel-popover-stage';
  popoverContent.id = 'paranovel-popover-content';
  anchor.id = 'paranovel-anchor';
  popover.classList.remove('with-show-more-button');

  const rtsInRange = [...document.querySelectorAll('rt')].filter(
    rt => !tokenRange.intersectsNode(rt),
  );

  /**
   * Workaround for a horrible WebKit-only bug, affecting both macOS Safari 17.6
   * and the Safari shipped with iOS 18.1 (both WebKit 605.1.15), whereby an
   * opaque highlight is composited over the <rt>, completely obscuring it.
   *
   * By using isolation: isolate, we force a new stacking context. This is a
   * vital alternative to z-index, which was not working - though opacity 0.999
   * would have equally worked:
   * @see https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_positioned_layout/Understanding_z-index/Stacking_context
   */
  const rtIsolationHack = {
    // It would be more intuitive to opt in to isolation rather than opt out,
    // but opting in leads to a visible flash on the anchor <rt>.
    apply: () => {
      rtsInRange.forEach(rt => {
        rt.style.setProperty('isolation', 'auto');
      });
    },
    remove: () => {
      rtsInRange.forEach(rt => {
        rt.style.removeProperty('isolation');
      });
    },
  };

  if (!popover.isConnected) {
    document.body.prepend(popover);
    popover.appendChild(popoverStage);
    popoverStage.appendChild(popoverContent);

    popover.addEventListener('click', onClose);
  }
  if (!anchor.isConnected) {
    document.body.prepend(anchor);
  }

  // UI ported over from Paranovel v1's `src/screens/novel/DictView.tsx`.
  // The container here maps to DictView's `ScrollView`, but we hoist its styles
  // up to #paranovel-popover's CSS declaration instead.

  const defaultFontSize = '14px';

  const container = document.createDocumentFragment();

  if (!results?.length) {
    const p = document.createElement('p');
    p.style.margin = '0';
    p.style.color = 'white';
    p.style.fontSize = defaultFontSize;
    p.textContent = 'No results.';
    container.appendChild(p);
  }

  const resultsFragment = document.createDocumentFragment();
  for (const { forms, senses } of results) {
    const readings = forms
      .sort((a, b) => (b.common ? 1 : 0) - (a.common ? 1 : 0))
      .filter(({ kana }) => kana);

    // <Result>
    const resultContainer = document.createElement('div');
    resultContainer.classList.add('paranovel-result-container');

    const headWord = document.createElement('p');
    headWord.classList.add('paranovel-headword');
    headWord.textContent = forms
      .filter(({ kana }) => !kana)
      .map(({ common, form }) => (common ? form : `Ôºà${form}Ôºâ`))
      .join('„ÄÅ');
    resultContainer.appendChild(headWord);

    const readingItem = document.createElement('p');
    readingItem.classList.add('paranovel-reading-item');
    readingItem.textContent = readings
      // Could represent uncommon using dice
      .map(({ common, form }) => (common ? form : `Ôºà${form}Ôºâ`))
      .join('„ÄÅ');
    resultContainer.appendChild(readingItem);

    const senseList = document.createElement('div');
    senseList.classList.add('paranovel-sense-list');
    for (const [i, { pos, gloss }] of senses.entries()) {
      const senseItem = document.createElement('div');
      senseItem.classList.add('paranovel-sense-item');

      const posList = document.createElement('ul');
      posList.classList.add('paranovel-pos-list');
      for (const textContent of pos) {
        const posItem = document.createElement('li');
        posItem.classList.add('paranovel-pos-item');
        posItem.textContent = textContent;
        posList.appendChild(posItem);
      }
      senseItem.appendChild(posList);

      const glossItem = document.createElement('p');
      glossItem.classList.add('paranovel-gloss-item');
      glossItem.textContent = `${i + 1}. ${gloss.join('; ')}`;
      senseItem.appendChild(glossItem);

      senseList.appendChild(senseItem);
    }

    resultContainer.appendChild(senseList);
    resultsFragment.appendChild(resultContainer);
  }
  const showMoreContainer = document.createElement('div');
  showMoreContainer.classList.add('paranovel-show-more-container');
  const showMoreButton = document.createElement('button');
  showMoreButton.classList.add('paranovel-show-more-button');
  showMoreButton.textContent = 'Show more';
  showMoreContainer.appendChild(showMoreButton);
  resultsFragment.appendChild(showMoreContainer);

  container.appendChild(resultsFragment);
  popoverContent.replaceChildren(container);

  // Now that we've got these anchors, we know the nodes and elements
  // encompassed by the selected tokens. From here, we want to anchor the
  // popover to them. Safari 26 does implement Anchor Positioning, but
  // `height: 100%` is practically useless, meaning we would have to do manual
  // layout to bound the popover height properly (and give up on position-try).
  //
  // At that rate, about the only benefit Anchor Positioning would give us would
  // be the ability to align to the centre of the anchor.
  //
  // So, if not Anchor Positioning, what are our options? Now that we've got
  // element "anchors", we can use HTMLElement.prototype.offsetLeft (etc.)
  // instead of getBoundingClientRect(), so rather than laying out relative to
  // the viewport (fixed positioning) we can finally draw relative to the
  // scroll container (absolute positioning), allowing the popover to scroll
  // along with the page.
  //
  // So, we have that option now. But it's tempting to go with fixed positioning
  // just so that we can call range.getBoundingClientRect() instead of
  // maintaining this complex element anchors code. With the new Popover API
  // (supported in iOS 18), we could block body scroll and make the popover
  // disappear upon clicking on the backdrop, so there'd be no need to mind
  // about it scrolling along with the page.

  document.body.classList.add('modal');
  rtIsolationHack.apply();
  popover.dataset.open = '';
  popover.style.setProperty('visibility', 'hidden');
  const orientation = layOutPopover({
    anchor,
    popoverStage,
    popoverContent,
    tokenRange,
  });
  if (!orientation) {
    onClose();
    return;
  }
  popoverContent.scrollTop = 0;
  popover.style.setProperty('visibility', 'visible');

  /** @param {MouseEvent} event */
  function onClose(event) {
    if (popoverContent.contains(event.target)) {
      console.log('contained', event.currentTarget);
      return;
    }
    console.log('out!');

    delete popover.dataset.open;
    __paranovelState.wordHighlight.clear();
    rtIsolationHack.remove();

    // Stop this click propagating to the document-level click handler.
    event.stopPropagation();

    document.body.classList.remove('modal');
  }
}

/**
 * @param {object} obj
 * @param {HTMLDivElement} obj.anchor
 * @param {HTMLElement} obj.popoverStage
 * @param {HTMLElement} obj.popoverContent
 * @param {Range} obj.tokenRange
 */
function layOutPopover({ anchor, popoverStage, popoverContent, tokenRange }) {
  const anchorRect = getEffectiveBoundingClientRect(tokenRange);
  console.log(
    `Anchor:\n- bounds:${JSON.stringify(anchorRect.toJSON())}\n${JSON.stringify(
      [...tokenRange.getClientRects()],
    )}`,
  );
  anchor.style.left = `${anchorRect.left}px`;
  anchor.style.top = `${anchorRect.top}px`;
  anchor.style.width = `${anchorRect.width}px`;
  anchor.style.height = `${anchorRect.height}px`;

  const endContainerElement =
    tokenRange.endContainer instanceof Element
      ? tokenRange.endContainer
      : tokenRange.endContainer.parentElement;
  /** @type {"horizontal-tb" | "vertical-rl" | "vertical-lr" | "sideways-lr" | "sideways-rl"} */
  const writingMode =
    endContainerElement?.computedStyleMap().get('writing-mode').value ??
    'horizontal-tb';

  /**
   * A tactic to emulate the following CSS:
   *
   * ```css
   * position-area: block-end span-all;
   * position-try: most-block-size flip-block;
   * ```
   *
   * @type {["bottom", "top"] | ["right", "left"] | ["left", "right"]}
   */
  let positionTryOrder;
  switch (writingMode) {
    case 'lr':
    case 'lr-tb':
    case 'rl':
    case 'horizontal-tb': {
      positionTryOrder = ['bottom', 'top'];
      popoverStage.style.overflow = '';
      break;
    }
    case 'tb-lr':
    case 'tb-rl':
    case 'sideways-rl':
    case 'vertical-rl':
    case 'sideways-lr':
    case 'vertical-lr': {
      positionTryOrder = writingMode.endsWith('rl')
        ? ['left', 'right']
        : ['right', 'left'];
      break;
    }
    default: {
      throw new Error(`Unexpected writing mode, ${writingMode}`);
    }
  }

  /** @type {Array<{ orientation: Orientation, overflow: number }>} */
  const overflows = [];
  /** @type {Orientation} */
  let lastTried;
  for (const orientation of positionTryOrder) {
    lastTried = orientation;
    const { blockOverflow, inlineOverflow, isOverflowingViewport, stageRect } =
      tryOrientation({
        popoverStage,
        popoverContent,
        anchorRect,
        orientation,
      });

    if (isOverflowingViewport) {
      console.log(
        `Discarding orientation "${orientation}" as it's overflowing the viewport.`,
        stageRect,
      );
      continue;
    }
    if (inlineOverflow) {
      console.log(
        `Discarding orientation "${orientation}" as it's overflowing in the inline orientation.`,
        stageRect,
      );
      continue;
    }

    overflows.push({ orientation, overflow: blockOverflow });

    if (!blockOverflow) {
      break;
    }
  }

  const sortedOverflows = overflows.sort((a, b) => a.overflow - b.overflow);
  const leastOverflow = sortedOverflows.at(0)?.orientation;

  if (!leastOverflow) {
    return;
  }

  if (leastOverflow === lastTried) {
    console.log(
      `Given overflows ${JSON.stringify(
        sortedOverflows,
      )}, picking ${leastOverflow} (last tried)`,
    );
  } else {
    console.log(
      `Given overflows ${JSON.stringify(
        sortedOverflows,
      )}, picking ${leastOverflow} (redoing layout)`,
    );

    tryOrientation({
      popoverStage,
      popoverContent,
      anchorRect,
      orientation: leastOverflow,
    });
  }

  return leastOverflow;
}

/**
 * When a range begins with a character that follows straight after a soft line
 * wrap, the bounding client rect may span two lines despite the only visible
 * character(s) being in the trailing client rect.
 *
 * This function gets the "effective" bounding client rect by removing any
 * client rects with zero width or zero height, and unioning the rest.
 *
 * @param {Range} range
 */
function getEffectiveBoundingClientRect(range) {
  /** @type {DOMRect | undefined} */
  let current;
  for (const rect of range.getClientRects()) {
    const { x, y, top, right, bottom, left, width, height } = rect;

    if (!width || !height) {
      continue;
    }

    if (!current) {
      current = new DOMRect(x, y, width, height);
      continue;
    }

    const leftmost = Math.min(left, current.left);
    const topmost = Math.min(top, current.top);
    const rightmost = Math.max(right, current.right);
    const bottommost = Math.max(bottom, current.bottom);

    // While x, y, width, and height are mutable, the more convenient cardinal
    // directions are not.
    current = new DOMRect(
      leftmost,
      topmost,
      rightmost - leftmost,
      bottommost - topmost,
    );
  }

  return current ?? range.getBoundingClientRect();
}

/** @typedef {'top' | 'right' | 'bottom' | 'left'} Orientation */

/**
 * @param {object} args
 * @param {HTMLElement} args.popoverStage
 * @param {HTMLElement} args.popoverContent
 * @param {DOMRect} args.anchorRect
 * @param {Orientation} args.orientation
 */
function tryOrientation({
  popoverStage,
  popoverContent,
  anchorRect,
  orientation,
}) {
  // `anchorRect` is measured entirely from the top-left (i.e. `bottom` is the
  // number of pixels down from the top; it's equivalent to `top` + `height`).
  const { top, left, bottom, right } = anchorRect;

  popoverStage.style.removeProperty('top');
  popoverStage.style.removeProperty('right');
  popoverStage.style.removeProperty('bottom');
  popoverStage.style.removeProperty('left');

  /**
   * For now, the popover is always formatted as horizontal-lr, even if the
   * ebook is vertical-rl. This is, in chief, because I'm starting with a
   * Japanese-English dictionary, and vertical-rl does not suit English text.
   */
  const popoverWritingDirectionMatchesBodyText = false;

  /** @type {number} */
  let blockOverflow = 0;
  let inlineOverflow = 0;

  switch (orientation) {
    case 'top': {
      popoverStage.style.flexDirection = 'column';
      popoverStage.style.justifyContent = 'flex-end';
      popoverStage.style.bottom = `${window.innerHeight - top}px`;
      blockOverflow = popoverContent.scrollHeight - popoverContent.clientHeight;
      inlineOverflow = popoverContent.scrollWidth - popoverContent.clientWidth;
      break;
    }
    case 'right': {
      popoverStage.style.flexDirection = 'row';
      popoverStage.style.justifyContent = 'flex-start';
      popoverStage.style.left = `${right}px`;
      if (popoverWritingDirectionMatchesBodyText) {
        blockOverflow = popoverContent.scrollWidth - popoverContent.clientWidth;
        inlineOverflow =
          popoverContent.scrollHeight - popoverContent.clientHeight;
      } else {
        blockOverflow =
          popoverContent.scrollHeight - popoverContent.clientHeight;
        inlineOverflow =
          popoverContent.scrollWidth - popoverContent.clientWidth;
      }
      break;
    }
    case 'bottom': {
      popoverStage.style.flexDirection = 'column';
      popoverStage.style.justifyContent = 'flex-start';
      popoverStage.style.top = `${bottom}px`;
      blockOverflow = popoverContent.scrollHeight - popoverContent.clientHeight;
      inlineOverflow = popoverContent.scrollWidth - popoverContent.clientWidth;
      break;
    }
    case 'left': {
      popoverStage.style.flexDirection = 'row';
      popoverStage.style.justifyContent = 'flex-end';
      popoverStage.style.right = `${window.innerWidth - left}px`;
      if (popoverWritingDirectionMatchesBodyText) {
        blockOverflow = popoverContent.scrollWidth - popoverContent.clientWidth;
        inlineOverflow =
          popoverContent.scrollHeight - popoverContent.clientHeight;
      } else {
        blockOverflow =
          popoverContent.scrollHeight - popoverContent.clientHeight;
        inlineOverflow =
          popoverContent.scrollWidth - popoverContent.clientWidth;
      }
      break;
    }
  }

  const stageRect = popoverContent.getBoundingClientRect();

  // Although the anchor may be fully onscreen, some orientations around it may
  // cause the popover to fall offscreen.
  let isOverflowingViewport = false;
  if (
    stageRect.top < 0 ||
    stageRect.left < 0 ||
    stageRect.bottom > window.innerHeight ||
    stageRect.right > window.innerWidth
  ) {
    isOverflowingViewport = true;
  }

  return { blockOverflow, inlineOverflow, isOverflowingViewport, stageRect };
}

/**
 * Wraps any direct bare text node children in a `<ruby>` with `<rb>`:
 *
 * ```diff
 * - <ruby>ÊòéÊó•<rt>„ÅÇ„Åó„Åü</rt></ruby>
 * + <ruby><rb>ÊòéÊó•</rb><rt>„ÅÇ„Åó„Åü</rt></ruby>
 * ```
 *
 * @param root {Element}
 */
function wrapRubyBaseTextsWithRb(root) {
  for (const ruby of root.querySelectorAll('ruby')) {
    for (const childNode of ruby.childNodes) {
      if (childNode.nodeName !== '#text') {
        continue;
      }
      const rb = document.createElement('rb');
      ruby.replaceChild(rb, childNode);
      rb.appendChild(childNode);
    }
  }
}

/**
 * Prepend a prelude and append a postlude into the <body>.
 */
function insertNavigationButtons(body) {
  // TODO: style Previous & Next as primary, and the Jump buttons as secondary.
  const commonStyles =
    'display: flex; justify-content: center; align-items: center; column-gap: 8px;';

  const prelude = `
<div id="paranovel-prelude" style="${commonStyles} padding-block-end: 16px;">
  <button id="paranovel-previous" type="button" style="writing-mode: horizontal-tb;">Previous</button>
  <button id="paranovel-end" type="button" style="writing-mode: horizontal-tb;">Jump to end</button>
</div>
  `.trim();

  const postlude = `
<div id="paranovel-postlude" style="${commonStyles} padding-block-start: 16px;">
  <button id="paranovel-start" type="button" style="writing-mode: horizontal-tb;">Return to start</button>
  <button id="paranovel-next" type="button" style="writing-mode: horizontal-tb;">Next</button>
</div>
  `.trim();

  for (const html of [postlude, prelude]) {
    const template = document.createElement('template');
    template.innerHTML = html;
    const dom = template.content.firstChild;

    switch (dom.id) {
      case 'paranovel-prelude': {
        const prev = dom.querySelector('#paranovel-previous');
        prev.onclick = event => {
          window.ReactNativeWebView.postMessage(
            JSON.stringify({
              type: 'navigation-request',
              value: 'prev',
              currentHref: location.href,
            }),
          );
        };

        const end = dom.querySelector('#paranovel-end');
        end.onclick = event => {
          document.body.scrollIntoView({
            block: 'end',
            inline: 'end',
            behavior: 'instant',
          });
        };

        body.prepend(dom);
        break;
      }
      case 'paranovel-postlude': {
        const next = dom.querySelector('#paranovel-next');
        next.onclick = event => {
          window.ReactNativeWebView.postMessage(
            JSON.stringify({
              type: 'navigation-request',
              value: 'next',
              currentHref: location.href,
            }),
          );
        };

        const start = dom.querySelector('#paranovel-start');
        start.onclick = event => {
          document.body.scrollIntoView({
            block: 'start',
            inline: 'start',
            behavior: 'instant',
          });
        };

        body.append(dom);
        break;
      }
    }
  }
}

function log(message) {
  window.ReactNativeWebView.postMessage(
    JSON.stringify({ type: 'log', message }),
  );
}

/**
 * @param {MouseEvent} event
 */
async function onClickDocument(event) {
  const { x, y, target } = event;

  if (
    document.getElementById('paranovel-popover')?.contains(target) ||
    document.getElementById('paranovel-prelude')?.contains(target) ||
    document.getElementById('paranovel-postlude')?.contains(target)
  ) {
    // Don't attempt to look up text for any clicks within Paranovel UI
    // elements.
    return;
  }

  const anchor = document.getElementById('paranovel-anchor');
  if (anchor?.childNodes.length) {
    dissolveAnchor(anchor);
  }

  // This rounds to the nearest glyph. That is to say, given the text "abc",
  // your click will be funnelled into "b" if it is:
  // 1. in the last 50% (in the inline direction) of a;
  // 2. within b itself;
  // 3. in the first 50% (in the inline direction) of b.
  const caretRange = document.caretRangeFromPoint(x, y);
  if (!caretRange) {
    log('‚ùå no caret range');
    return;
  }

  console.log(`document.caretRangeFromPoint(${x}, ${y})`);
  const adjustedRange = compensateForHitSlop({ caretRange, x, y });

  const surroundingText = getSurroundingText(adjustedRange);
  if (!surroundingText) {
    log('‚ùå no surrounding text');
    return;
  }
  // console.log(surroundingText);
  const {
    blockBaseText,
    closestBlock,
    offsetOfTargetBaseTextIntoBlockBaseText,
    targetNode,
  } = surroundingText;

  const id = __paranovelState.tokenizationPromiseCount++;

  let response;
  try {
    response = await new Promise((resolve, reject) => {
      __paranovelState.tokenizationPromiseHandlers[id] = { resolve, reject };

      // Promise is settled by onNovelViewMessage calling resolve/reject
      window.ReactNativeWebView.postMessage(
        JSON.stringify({
          type: 'tokenize',
          id,
          blockBaseText,
          offset: offsetOfTargetBaseTextIntoBlockBaseText,
        }),
      );
    });
  } catch (error) {
    console.error('Tokenize Promise rejected with error', error);
    log(
      `‚ùå Tokenize Promise rejected${
        error instanceof Error ? ` with error: "${error.message}"` : '.'
      }`,
    );
  } finally {
    delete __paranovelState.tokenizationPromiseHandlers[id];
  }

  const {
    dictionaryForm,
    tokenLength,
    offsetOfTargetTokenIntoBlockBaseText,
    offsetOfTargetCharacterIntoBlockBaseText,
  } = response;
  log(
    `üìñ dictionaryForm: "${dictionaryForm}"; tokenOffset: ${offsetOfTargetTokenIntoBlockBaseText}, characterOffset: ${offsetOfTargetCharacterIntoBlockBaseText}; length: ${tokenLength}`,
  );

  const tokenRange = getRangeFromOffsetIntoBlockBaseText({
    blockElement: closestBlock,
    blockBaseText,
    startOffset: offsetOfTargetTokenIntoBlockBaseText,
    endOffset: offsetOfTargetTokenIntoBlockBaseText + tokenLength,
  });
  if (!tokenRange) {
    return;
  }

  // If we're inside a base text of a <ruby> (whether a text node or an <rb>),
  // and the selection range terminates at the end of that base text, then
  // search for the matching <rt> and extend the highlight to include that.
  const { endContainer, endOffset } = tokenRange;
  if (
    (endContainer instanceof CharacterData &&
      endOffset === endContainer.data.length) ||
    endOffset === endContainer.childNodes.length
  ) {
    const endContainerElement =
      endContainer instanceof Element
        ? endContainer
        : endContainer.parentElement;
    const endContainerRuby = endContainerElement?.closest('ruby');
    if (endContainerRuby) {
      /** @type {HTMLElement | undefined} */
      let correspondingRt;
      for (const node of traverseFollowingText(
        endContainerElement,
        'next',
        endContainerRuby,
      )) {
        if (node.nodeName.toUpperCase() === 'RT') {
          correspondingRt = node;
          break;
        }
      }
      if (correspondingRt) {
        tokenRange.setEnd(correspondingRt, correspondingRt.childNodes.length);
      }
    }
  }

  console.log('onClickDocument', { tokenRange });
  window.tokenRange = tokenRange;
  __paranovelState.wordHighlight.add(tokenRange);

  log(`üîé Looking up term "${dictionaryForm}"`);
  lookUpTerm({
    tokenRange,
    dictionaryForm,
  });
}

/**
 * @param {object} args
 * @param {Range} args.caretRange
 * @param {number} args.x
 * @param {number} args.y
 */
function compensateForHitSlop({ caretRange, x, y }) {
  const surroundingRanges = getCaretSurroundingRanges(caretRange);
  if (!surroundingRanges) {
    return caretRange;
  }

  const { leading, trailing } = surroundingRanges;
  const leadingRect = leading.getBoundingClientRect();
  const trailingRect = trailing.getBoundingClientRect();

  console.log(`  [MIDDLE]\n${debugRange(caretRange)}`);
  console.log(
    ` [LEADING] "${leading.toString()}"\n${debugRange(
      leading,
    )}\n${JSON.stringify(leadingRect.toJSON())}`,
  );
  console.log(
    `[TRAILING] "${trailing.toString()}"\n${debugRange(
      trailing,
    )}\n${JSON.stringify(trailingRect.toJSON())}`,
  );

  if (isPointInRect({ rect: leadingRect, x, y })) {
    console.log(`Picking leading range: "${leading.toString()}"`);
    return leading;
  }

  if (isPointInRect({ rect: trailingRect, x, y })) {
    console.log(`Picking trailing range: "${trailing.toString()}"`);
    return trailing;
  }

  return caretRange;
}

/**
 * @param {object} args
 * @param {DOMRect} args.rect
 * @param {number} args.x
 * @param {number} args.y
 */
function isPointInRect({ rect, x, y }) {
  return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
}

/**
 * @param {Range} caret
 */
function getCaretSurroundingRanges(caret) {
  /** @type {Range | undefined} */
  let leading;
  if (isTextNode(caret.startContainer)) {
    if (caret.startOffset) {
      const range = new Range();
      range.setStart(caret.startContainer, caret.startOffset - 1);
      range.setEnd(caret.startContainer, caret.startOffset);
      leading = range;
    } else {
      for (const node of traverseFollowingText(
        caret.startContainer,
        'prev',
        document.body,
        false,
      )) {
        if (!isTextNode(node) || !node.data.length) {
          continue;
        }
        const range = new Range();
        range.setStart(node, node.data.length - 1);
        range.setEnd(node, node.data.length);
        leading = range;
        break;
      }
    }
  } else if (isElement(caret.startContainer)) {
    /** @type {Node} */
    let boundaryPoint;
    if (caret.startOffset) {
      boundaryPoint =
        caret.startContainer.childNodes.item(caret.startOffset - 1) ??
        caret.startContainer;
    } else {
      boundaryPoint = caret.startContainer;
    }

    for (const node of traverseFollowingText(
      boundaryPoint,
      'prev',
      document.body,
      false,
    )) {
      if (!isTextNode(node) || !node.data.length) {
        continue;
      }
      const range = new Range();
      range.setStart(node, node.data.length - 1);
      range.setEnd(node, node.data.length);
      leading = range;
      break;
    }
  }

  if (!leading) {
    return;
  }

  /** @type {Range | undefined} */
  let trailing;
  if (isTextNode(caret.endContainer)) {
    if (caret.endOffset < caret.endContainer.data.length) {
      const range = new Range();
      range.setStart(caret.endContainer, caret.endOffset);
      range.setEnd(caret.endContainer, caret.endOffset + 1);
      trailing = range;
    } else {
      for (const node of traverseFollowingText(
        caret.endContainer,
        'next',
        document.body,
        false,
      )) {
        if (!isTextNode(node) || !node.data.length) {
          continue;
        }
        const range = new Range();
        range.setStart(node, 0);
        range.setEnd(node, 1);
        trailing = range;
        break;
      }
    }
  } else if (isElement(caret.endContainer)) {
    /** @type {Node} */
    let boundaryPoint;
    if (caret.endOffset) {
      boundaryPoint =
        caret.endContainer.childNodes.item(caret.startOffset - 1) ??
        caret.endContainer;
    } else {
      boundaryPoint = caret.endContainer;
    }

    for (const node of traverseFollowingText(
      boundaryPoint,
      'next',
      document.body,
      false,
    )) {
      if (!isTextNode(node) || !node.data.length) {
        continue;
      }
      const range = new Range();
      range.setStart(node, 0);
      range.setEnd(node, 1);
      trailing = range;
      break;
    }
  }

  if (!trailing) {
    return;
  }

  return { leading, trailing };
}

/** @param {Range} range  */
function debugRange(range) {
  const { startContainer, startOffset, endContainer, endOffset } = range;

  if (startContainer === endContainer) {
    if (isTextNode(startContainer)) {
      const windowSize = 3;
      const preview = startContainer.data.slice(
        startOffset - windowSize,
        endOffset + windowSize,
      );
      const pointer = startContainer.data
        .slice(startOffset - windowSize, endOffset)
        .replace(/(.)(?!$)/g, '„Éº')
        .replace(/.$/, 'Ôºæ');
      return `${preview}\n${pointer}${startOffset === endOffset ? 'Ôºæ' : ''}`;
    }
  }

  return '<complex>';
}

function getViewportScrollLeft() {
  // I think this calculation only holds up as long as overflow is hidden on the
  // viewport.
  return document.body.scrollLeft;
}
function getViewportScrollTop() {
  // I think scrollLeft ended up much more complicated just because we had to
  // support right-to-left content, but web specs don't have a concept of
  // bottom-to-top, so we can handle everything as if it's top-to-bottom.
  return document.body.scrollTop;
}

/**
 *
 * @param {object} obj
 * @param {string} obj.dictionaryForm
 * @param {Range} obj.tokenRange
 */
async function lookUpTerm({ dictionaryForm, tokenRange }) {
  const id = __paranovelState.tokenizationPromiseCount++;

  /** @type {string} */
  let response;
  try {
    response = await new Promise((resolve, reject) => {
      __paranovelState.tokenizationPromiseHandlers[id] = { resolve, reject };

      // Promise is settled by onNovelViewMessage calling resolve/reject
      window.ReactNativeWebView.postMessage(
        JSON.stringify({
          type: 'lookUpTerm',
          term: dictionaryForm,
          id,
        }),
      );
    });
  } catch (error) {
    console.error('lookUpTerm Promise rejected with error', error);
    log(
      `‚ùå lookUpTerm Promise rejected${
        error instanceof Error ? ` with error: "${error.message}"` : '.'
      }`,
    );
    return;
  } finally {
    delete __paranovelState.tokenizationPromiseHandlers[id];
  }

  updatePopover({
    results: response,
    tokenRange,
  });
}

function getRangeFromOffsetIntoBlockBaseText({
  blockElement,
  blockBaseText,
  startOffset,
  endOffset,
}) {
  if (!(blockElement instanceof HTMLElement)) {
    throw new TypeError('Expected blockElement to be an HTML Element.');
  }

  if (startOffset < 0 || startOffset > blockBaseText.length) {
    throw new DOMException(
      'The index is not in the allowed range.',
      'IndexSizeError',
    );
  }

  let offset = 0;
  const range = document.createRange();
  let foundStartOffset = false;
  let prevNode = null;
  for (const node of traverseBaseText(blockElement)) {
    const actual = node.textContent;
    const expected = blockBaseText.slice(offset, offset + actual.length);
    if (actual !== expected) {
      throw new Error(
        'Expected to be able to reproduce the originally extracted base text when retraversing the same block.',
      );
    }

    // If the offsets lie within this node, set the range accordingly.
    //
    // When there are multiple possible solutions due to the range being on a
    // boundary between two nodes, prefer to keep the range as small as
    // possible.
    //
    // Note that we blindly assume a forward range (startOffset < endOffset).

    // For startOffset, prefer the following node (thus >)
    if (!foundStartOffset && offset + actual.length > startOffset) {
      const offsetWithinNode = startOffset - offset;
      range.setStart(node, offsetWithinNode);
      foundStartOffset = true;
    }

    // For endOffset, prefer the current node (thus >=)
    if (foundStartOffset && offset + actual.length >= endOffset) {
      const offsetWithinNode = endOffset - offset;
      range.setEnd(node, offsetWithinNode);
      return range;
    }

    offset += actual.length;
    prevNode = node;
  }

  return null;
}

function getSurroundingText(range) {
  const { startContainer: targetNode, startOffset: targetOffset } = range;
  if (!(targetNode instanceof Text)) {
    return;
  }

  const element = targetNode.parentElement;
  if (!element) {
    return;
  }

  const closestRuby = element.closest('ruby');
  const blockElementsSelector =
    'address,article,aside,blockquote,canvas,dd,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hr,li,main,nav,noscript,ol,p,pre,section,table,tfoot,ul,video';
  const closestBlock = element.closest(blockElementsSelector);

  let leadingBaseText = '';
  let targetBaseText = '';
  let trailingBaseText = '';
  for (const { baseTextContent, stage } of traverseBlock(targetNode)) {
    switch (stage) {
      case BlockTraversalStage.leading: {
        leadingBaseText = `${baseTextContent}${leadingBaseText}`;
        break;
      }
      case BlockTraversalStage.target: {
        targetBaseText = baseTextContent;
        break;
      }
      case BlockTraversalStage.trailing: {
        trailingBaseText = `${trailingBaseText}${baseTextContent}`;
        break;
      }
    }
  }

  const offsetOfTargetBaseTextIntoBlockBaseText =
    leadingBaseText.length + (closestRuby ? 0 : targetOffset);
  const blockBaseText = leadingBaseText + targetBaseText + trailingBaseText;

  return {
    leadingBaseText,
    targetNode,
    targetBaseText,
    targetBaseTextSliced: targetBaseText.slice(
      offsetOfTargetBaseTextIntoBlockBaseText,
    ),
    trailingBaseText,
    closestBlock,
    blockBaseText,
    offsetOfTargetBaseTextIntoBlockBaseText,
  };
}

function* traverseBlock(textNode) {
  if (!(textNode instanceof Text)) {
    return;
  }

  const element = textNode.parentElement;
  if (!element) {
    return;
  }

  const closestRuby = element.closest('ruby');
  const pivot = closestRuby ?? textNode;
  const blockElementsSelector =
    'address,article,aside,blockquote,canvas,dd,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hr,li,main,nav,noscript,ol,p,pre,section,table,tfoot,ul,video';
  const closestBlock = element.closest(blockElementsSelector);

  for (const node of traverseFollowingText(pivot, 'previous', closestBlock)) {
    const baseTextContent = getBaseTextContent(node);
    yield { baseTextContent, stage: BlockTraversalStage.leading };
  }

  const targetBaseText = getBaseTextContent(pivot);
  yield { baseTextContent: targetBaseText, stage: BlockTraversalStage.target };

  for (const node of traverseFollowingText(pivot, 'next', closestBlock)) {
    const baseTextContent = getBaseTextContent(node);
    yield { baseTextContent, stage: BlockTraversalStage.trailing };
  }
}

const BlockTraversalStage = {
  leading: 0,
  target: 1,
  trailing: 2,
};

function getFollowingText(node, direction, untilAncestor) {
  let followingText = '';

  if (direction === 'next') {
    for (const node of traverseFollowingText(node, direction, untilAncestor)) {
      const baseTextContent = getBaseTextContent(node);
      followingText = `${followingText}${baseTextContent}`;
    }
  } else {
    for (const node of traverseFollowingText(node, direction, untilAncestor)) {
      const baseTextContent = getBaseTextContent(node);
      followingText = `${baseTextContent}${followingText}`;
    }
  }

  return followingText;
}

/**
 * @param {Node} node
 * @param {"prev" | "next"} direction
 * @param {Node} [untilAncestor]
 * @param {boolean} [shallow] If true, climbs up parents but does not dig down
 * into children. If false, climbs up parents and digs down into children.
 */
function* traverseFollowingText(
  node,
  direction,
  untilAncestor,
  shallow = true,
) {
  /**
   * @param {Node} node
   */
  const getChildCandidate = node =>
    !shallow && isElement(node)
      ? direction === 'next'
        ? node.firstChild
        : node.lastChild
      : null;

  const childCandidate = getChildCandidate(node);
  let parent = childCandidate ? node : node.parentElement;
  let sibling =
    childCandidate ??
    (direction === 'next' ? node.nextSibling : node.previousSibling);

  while (true) {
    // If we've reached the end of the run, climb up to the parent and continue.
    while (!sibling) {
      if (!parent || parent === untilAncestor) {
        return;
      }

      sibling =
        direction === 'next' ? parent.nextSibling : parent.previousSibling;

      parent = parent.parentElement;
    }

    yield sibling;

    const childCandidate = getChildCandidate(sibling);
    parent = childCandidate ? sibling : parent;

    sibling =
      childCandidate ??
      (direction === 'next' ? sibling.nextSibling : sibling.previousSibling);
  }
}

function* traverseBaseText(node) {
  const treeWalker = document.createTreeWalker(
    node,
    // We need SHOW_ELEMENT to filter out all <rt> subtrees, while the payload
    // we're actually interested in is SHOW_TEXT.
    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT,
    node => {
      switch (node.nodeName) {
        // Element nodeNames are uppercase in HTML, yet lowercase in XHTML
        case 'rt':
        case 'RT':
          return NodeFilter.FILTER_REJECT;
        case '#text':
          return NodeFilter.FILTER_ACCEPT;
        default:
          return NodeFilter.FILTER_SKIP;
      }
    },
  );

  // Make the traversal inclusive of the target node.
  if (node.nodeName === '#text') {
    yield node;
  }

  let nextNode;
  while ((nextNode = treeWalker.nextNode())) {
    yield nextNode;
  }
}

// Warning: does not return empty strings if called directly on/inside <rt>/<rp>
function getBaseTextContent(node) {
  let baseTextContent = '';
  for (const textNode of traverseBaseText(node)) {
    baseTextContent = `${baseTextContent}${textNode.textContent}`;
  }
  return baseTextContent;
}

/**
 * @param {Node} node
 * @returns {node is Text}
 */
function isTextNode(node) {
  return node.nodeType === Node.TEXT_NODE;
}

/**
 * @param {Node} node
 * @returns {node is Element}
 */
function isElement(node) {
  return node.nodeType === Node.ELEMENT_NODE;
}

const __paranovelState = {
  wordHighlight: new Highlight(),
  tokenizationPromiseCount: 0,
  tokenizationPromiseHandlers: {},
};

CSS.highlights.set('word', __paranovelState.wordHighlight);

insertNavigationButtons(document.body);
insertProgressBar(document.body);
document.addEventListener('click', onClickDocument);

document.addEventListener('dblclick', () => {
  // This no-op event listener is needed to prevent WebKit's "double-tap to
  // scroll" functionality, which is an anti-feature as far as our tap-driven
  // ebook reader app is concerned.
  //
  // The WebKit team told us in 2015 that we can opt out of it by either:
  // 1) adding `user-scalable=no` to the viewport <meta> tag, or;
  // 2) setting `touch-action: pan-x pan-y` in CSS.
  // https://webkit.org/blog/5610/more-responsive-tapping-on-ios/
  //
  // ‚Ä¶ But in practice in 2025, iOS Safari just ignores both of these. So here
  // we are, handling it in JavaScript like a chump.
  //
  // Why is this event handler empty, though? Surely we need to do something
  // like call event.preventDefault() in here, you cry. Well, no, actually. The
  // mere *presence* of a dblclick listener on the document triggers some
  // unexplained codepath in WebKit that abrogates the scrolling.
});

/**
 * @param {HTMLElement} container
 */
function insertProgressBar(container) {
  const progress = document.createElement('progress');
  progress.id = 'paranovel-progress';
  container.appendChild(progress);
  progress.max = 100;
  progress.value = 50;

  progress.style.position = 'fixed';
  progress.style.top = '1rem';
  progress.style.left = '0';
  progress.style.right = '0';
  progress.style.writingMode = 'horizontal-tb';
  progress.style.width = 'calc(100% - 2rem)';
  progress.style.marginInline = 'auto';
}
