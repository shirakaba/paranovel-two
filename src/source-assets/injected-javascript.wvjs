// Prevent restoring the last-scrolled position from a previous session.
history.scrollRestoration = 'manual';

{
  // Insert a viewport meta tag
  const meta = document.createElement('meta');
  meta.name = 'viewport';
  meta.content = 'width=device-width, initial-scale=1, user-scalable=no';
  document.head.appendChild(meta);
}

// Although <rb> is a deprecated element, on WebKit, the CSS Custom Highlight
// API simply doesn't highlight the bare text nodes, so we apply this change as
// a workaround.
wrapRubyBaseTextsWithRb(document.body);

/**
 * @param {object} obj
 * @param {DOMRect} obj.boundingClientRect
 * @param {DOMRect} [obj.clientRect]
 * @param {"horizontal-tb" | "vertical-rl" | "vertical-lr"} obj.writingMode the
 * writing mode of the range that has been highlighted (informing where the
 * popover should prefer to align to if the source rect is particularly large,
 * e.g. due to spanning two lines).
 * @param {Array<import("../../utils/look-up-term").LookupResult>} [obj.results]
 * @param {"block" | "none"} obj.display
 */
function updatePopover({
  boundingClientRect,
  clientRect = boundingClientRect,
  writingMode,
  display,
  results,
}) {
  log(`ℹ️ Got boundingClientRect ${JSON.stringify(boundingClientRect)}`);

  const arrow =
    document.getElementById('paranovel-arrow') ?? document.createElement('div');
  arrow.id = 'paranovel-arrow';

  if (!arrow.isConnected) {
    document.body.prepend(arrow);
  }

  const popover =
    document.getElementById('paranovel-popover') ??
    document.createElement('div');
  popover.id = 'paranovel-popover';
  popover.classList.remove('with-show-more-button');

  if (!popover.isConnected) {
    document.body.prepend(popover);
  }

  // UI ported over from Paranovel v1's `src/screens/novel/DictView.tsx`.
  // The container here maps to DictView's `ScrollView`, but we hoist its styles
  // up to #paranovel-popover's CSS declaration instead.

  const defaultFontSize = '14px';

  const container = document.createDocumentFragment();

  if (!results?.length) {
    const p = document.createElement('p');
    p.style.margin = '0';
    p.style.color = 'white';
    p.style.fontSize = defaultFontSize;
    p.textContent = 'No results.';
    container.appendChild(p);
    popover.replaceChildren(container);
    return;
  }

  const resultsFragment = document.createDocumentFragment();
  for (const { forms, senses } of results) {
    const readings = forms
      .sort((a, b) => (b.common ? 1 : 0) - (a.common ? 1 : 0))
      .filter(({ kana }) => kana);

    // <Result>
    const resultContainer = document.createElement('div');
    resultContainer.classList.add('paranovel-result-container');

    const headWord = document.createElement('p');
    headWord.classList.add('paranovel-headword');
    headWord.textContent = forms
      .filter(({ kana }) => !kana)
      .map(({ common, form }) => (common ? form : `（${form}）`))
      .join('、');
    resultContainer.appendChild(headWord);

    const readingItem = document.createElement('p');
    readingItem.classList.add('paranovel-reading-item');
    readingItem.textContent = readings
      // Could represent uncommon using dice
      .map(({ common, form }) => (common ? form : `（${form}）`))
      .join('、');
    resultContainer.appendChild(readingItem);

    const senseList = document.createElement('div');
    senseList.classList.add('paranovel-sense-list');
    for (const [i, { pos, gloss }] of senses.entries()) {
      const senseItem = document.createElement('div');
      senseItem.classList.add('paranovel-sense-item');

      const posList = document.createElement('ul');
      posList.classList.add('paranovel-pos-list');
      for (const textContent of pos) {
        const posItem = document.createElement('li');
        posItem.classList.add('paranovel-pos-item');
        posItem.textContent = textContent;
        posList.appendChild(posItem);
      }
      senseItem.appendChild(posList);

      const glossItem = document.createElement('p');
      glossItem.classList.add('paranovel-gloss-item');
      glossItem.textContent = `${i + 1}. ${gloss.join('; ')}`;
      senseItem.appendChild(glossItem);

      senseList.appendChild(senseItem);
    }

    resultContainer.appendChild(senseList);
    resultsFragment.appendChild(resultContainer);
  }
  const showMoreContainer = document.createElement('div');
  showMoreContainer.classList.add('paranovel-show-more-container');
  const showMoreButton = document.createElement('button');
  showMoreButton.classList.add('paranovel-show-more-button');
  showMoreButton.textContent = 'Show more';
  showMoreContainer.appendChild(showMoreButton);
  resultsFragment.appendChild(showMoreContainer);

  container.appendChild(resultsFragment);
  popover.replaceChildren(container);

  // Make sure to record these values before doing the first layout pass of the
  // popover, as I found the popover itself can budge the scroll. I think it may
  // happen if the popover overflows out of the viewport?
  const viewportScrollPosition = {
    scrollLeft: getViewportScrollLeft(),
    scrollTop: getViewportScrollTop(),
  };

  const popoverMinimumInlineSize = parseFloat(
    (
      getComputedStyle(popover).getPropertyValue(
        '--paranovel-popover-minimum-inline-size',
      ) || '0px'
    ).split('px')[0],
  );

  // == First layout pass ==
  // In this pass, we restrict the popover's inline size to something readable,
  // and let the block size expand as much as it likes in order to display all
  // its results.

  /**
   * @param {object} params
   * @param {boolean} params.hasMultipleResults
   * @param {number} params.popoverMinimumInlineSize
   * @param {number} params.blockSizeForShowMoreButton
   * @param {number} [params.maxInlineSize] The max inline size. Defaults to the
   * inline viewport size minus the inset size (or the configured max readable
   * inline size, if that is lower).
   * @param {"horizontal-tb" | "vertical-rl" | "vertical-lr"} params.popoverWritingMode
   */
  const getPreferredSize = ({
    hasMultipleResults,
    popoverMinimumInlineSize,
    blockSizeForShowMoreButton,
    popoverWritingMode,
    maxInlineSize,
  }) => {
    popover.style.left = 'var(--paranovel-popover-inset-size)';
    popover.style.top = 'var(--paranovel-popover-inset-size)';
    popover.style.boxSizing = 'border-box';
    popover.style.display = 'block';
    popover.style.visibility = 'hidden';

    // 'auto' may produce a floating-point number, while clientWidth and
    // clientHeight produce a floored version of that number
    popover.style.inlineSize = 'auto';
    popover.style.minInlineSize = `${popoverMinimumInlineSize}px`;
    popover.style.maxInlineSize = maxInlineSize
      ? `${maxInlineSize}px`
      : 'round(down, min(calc(100vi - var(--paranovel-popover-inset-size) * 2), var(--paranovel-max-readable-inline-size)), 1px)';
    popover.style.blockSize = 'auto';
    // popover.style.maxBlockSize = '50%';

    const popoverMaxInlineSize = parseFloat(
      getComputedStyle(popover).maxInlineSize.split('px')[0],
    );
    console.log('popoverMaxInlineSize', {
      popoverMaxInlineSize,
      clientWidth: popover.clientWidth,
    });

    // clientHeight/clientWidth floor the true values, so if you take their
    // values as written, you may end up underestimating the size needed to fit
    // content. We add an extra pixel to each size to prefer overestimating, and
    // clamp it to the computed maxInlineSize to avoid the added pixel breaking
    // the original constraints. This is less of a concern for the block size,
    // where an overestimate does not affect text flow.
    //
    // There may be other sub-pixel values to track down elsewhere in our
    // measurements (e.g. scroll position and bounding box).
    const popoverSizeToFitAllResults = {
      width:
        popoverWritingMode === 'horizontal-tb'
          ? Math.min(popover.clientWidth + 1, popoverMaxInlineSize)
          : popover.clientWidth + 1,
      height:
        popoverWritingMode === 'horizontal-tb'
          ? popover.clientHeight + 1
          : Math.min(popover.clientHeight + 1, popoverMaxInlineSize),
    };

    // When there are multiple results to show, we size the popover to fit just
    // the first result, providing a "show more" button to reveal the rest.
    let popoverSizeToFitFirstResult = popoverSizeToFitAllResults;
    // Avoid flushing layout again if there's only a single result container.
    if (hasMultipleResults) {
      popover.classList.add('size-to-first-result-container');
      // - Given that there are multiple results, we want to size to the inline
      //   size needed to display multiple results.
      // - We want the inline size to fit within the available space.
      // - But the clientWidth needed to fit one result is a logical size to
      //   snap to if we can't fit within that available inline size.
      popoverSizeToFitFirstResult = {
        width:
          popoverWritingMode === 'horizontal-tb'
            ? Math.min(
                Math.max(
                  popover.clientWidth + 1,
                  popoverSizeToFitAllResults.width,
                ),
                popoverMaxInlineSize,
              )
            : popover.clientWidth + 1,
        height:
          popoverWritingMode === 'horizontal-tb'
            ? popover.clientHeight + 1
            : Math.min(
                Math.max(
                  popover.clientHeight + 1,
                  popoverSizeToFitAllResults.height,
                ),
                popoverMaxInlineSize,
              ),
      };
      if (popoverWritingMode === 'horizontal-tb') {
        popoverSizeToFitFirstResult.height += blockSizeForShowMoreButton;
      } else {
        popoverSizeToFitFirstResult.width += blockSizeForShowMoreButton;
      }

      popover.classList.remove('size-to-first-result-container');
      popover.classList.add('with-show-more-button');
    }

    return { popoverSizeToFitAllResults, popoverSizeToFitFirstResult };
  };

  const blockSizeForShowMoreButton = parseFloat(
    (
      getComputedStyle(popover).getPropertyValue(
        '--paranovel-popover-show-more-button-block-size',
      ) || '0px'
    ).split('px')[0],
  );
  const popoverWritingMode = 'horizontal-tb';

  /**
   * @param {object} [params]
   * @param {number} [params.maxInlineSize] The max inline size. Defaults to the
   * inline viewport size minus the inset size (or the configured max readable
   * inline size, if that is lower).
   */
  const getPopoverPreferredSizes = ({ maxInlineSize } = {}) =>
    getPreferredSize({
      hasMultipleResults: results.length > 1,
      popoverMinimumInlineSize,
      blockSizeForShowMoreButton,
      popoverWritingMode,
      maxInlineSize,
    });

  const { popoverSizeToFitAllResults, popoverSizeToFitFirstResult } =
    getPopoverPreferredSizes();

  console.log(
    `popoverSizeToFitAllResults ${JSON.stringify(popoverSizeToFitAllResults)}`,
  );

  /** @type {boolean} Debug flag */
  const doSecondPass = true;
  if (!doSecondPass) {
    popover.style.visibility = 'visible';
    return;
  }

  // == Second layout pass ==
  // In this pass, we work out the "best" position to place the popup given the
  // available space around the target in the viewport, then lay it out there.

  // I'm not aware of a safer way to parse this, but we own the code, so I'm
  // being a bit reckless here.
  const popoverInsetSize = parseFloat(
    (
      getComputedStyle(popover).getPropertyValue(
        '--paranovel-popover-inset-size',
      ) || '0px'
    ).split('px')[0],
  );
  const popoverMinimumBlockSize = parseFloat(
    (
      getComputedStyle(popover).getPropertyValue(
        '--paranovel-popover-minimum-block-size',
      ) || '0px'
    ).split('px')[0],
  );

  /** @type {Parameters<typeof calculatePopoverLayout>[0]}  */
  const layoutArgs = {
    boundingClientRect,
    clientRect,
    sourceTextWritingMode: writingMode,
    popoverWritingMode,
    arrowSize: {
      breadth: 20,
      length: Math.ceil((13 / 15) * 20),
    },
    popoverInsetSize,
    popoverMinimumInlineSize,
    popoverMinimumBlockSize,
  };

  const layoutToFitAllResults = calculatePopoverLayout({
    ...layoutArgs,
    popoverPreferredSize: popoverSizeToFitAllResults,
    getPopoverPreferredSize: params =>
      getPopoverPreferredSizes(params).popoverSizeToFitAllResults,
  });
  const layoutToFitFirstResult = calculatePopoverLayout({
    ...layoutArgs,
    popoverPreferredSize: popoverSizeToFitFirstResult,
    getPopoverPreferredSize: params =>
      getPopoverPreferredSizes(params).popoverSizeToFitFirstResult,
  });

  console.log(
    `Got best popoverLayout ${JSON.stringify(
      layoutToFitFirstResult.best.popover,
    )}, given clientRect`,
    clientRect,
  );

  /**
   * @param {ReturnType<typeof calculatePopoverLayout>["best"]} layout
   */
  const setPopoverStyle = layout => {
    const popoverLayout = layout.popover;

    popover.style.left = `${
      viewportScrollPosition.scrollLeft + popoverLayout.x
    }px`;
    popover.style.top = `${
      viewportScrollPosition.scrollTop + popoverLayout.y
    }px`;
    popover.style.inlineSize = `${popoverLayout.width}px`;
    popover.style.maxInlineSize = `${popoverLayout.maxWidth}px`;
    popover.style.blockSize = `${popoverLayout.height}px`;
    popover.style.maxBlockSize = `${popoverLayout.maxHeight}px`;
    popover.style.visibility = 'visible';
    popover.style.position = 'absolute';
    popover.style.display = display;
  };

  const bestPopoverPlacementToFitFirstResult =
    layoutToFitFirstResult.best.popoverPlacement;
  setPopoverStyle(layoutToFitFirstResult.best);

  showMoreButton.onclick = () => {
    popover.classList.remove('with-show-more-button');

    const equivalentLayoutToFitAllResults = layoutToFitAllResults.sorted.find(
      ({ popoverPlacement }) =>
        popoverPlacement === bestPopoverPlacementToFitFirstResult,
    );

    setPopoverStyle(equivalentLayoutToFitAllResults);
  };

  const arrowLayout = layoutToFitFirstResult.best.arrow;
  arrow.style.position = 'absolute';
  arrow.style.left = `${viewportScrollPosition.scrollLeft + arrowLayout.x}px`;
  arrow.style.top = `${viewportScrollPosition.scrollTop + arrowLayout.y}px`;
  arrow.style.zIndex = '1';
  arrow.style.display = display;

  // TODO: If the arrow rendered outside of the viewport while the popover
  // stayed inside, we could consider just hiding the arrow.

  const arrowColor = 'var(--paranovel-popover-background-color)';
  switch (bestPopoverPlacementToFitFirstResult) {
    case 'below': {
      // arrow points up
      arrow.style.borderTop = 'initial';
      arrow.style.borderLeft = `${arrowLayout.width / 2}px solid transparent`;
      arrow.style.borderRight = `${arrowLayout.width / 2}px solid transparent`;
      arrow.style.borderBottom = `${arrowLayout.height}px solid ${arrowColor}`;
      break;
    }
    case 'above': {
      // arrow points down
      arrow.style.borderBottom = 'initial';
      arrow.style.borderLeft = `${arrowLayout.width / 2}px solid transparent`;
      arrow.style.borderRight = `${arrowLayout.width / 2}px solid transparent`;
      arrow.style.borderTop = `${arrowLayout.height}px solid ${arrowColor}`;
      break;
    }
    case 'on the left': {
      // arrow points right
      arrow.style.borderRight = 'initial';
      arrow.style.borderTop = `${arrowLayout.width / 2}px solid transparent`;
      arrow.style.borderBottom = `${arrowLayout.width / 2}px solid transparent`;
      arrow.style.borderLeft = `${arrowLayout.height}px solid ${arrowColor}`;
      break;
    }
    case 'on the right': {
      // arrow points left
      arrow.style.borderLeft = 'initial';
      arrow.style.borderTop = `${arrowLayout.width / 2}px solid transparent`;
      arrow.style.borderBottom = `${arrowLayout.width / 2}px solid transparent`;
      arrow.style.borderRight = `${arrowLayout.height}px solid ${arrowColor}`;
      break;
    }
  }
}

/**
 *
 * @param {object} params
 * @param {DOMRect} params.boundingClientRect The bounds of the whole highlighted
 * range. The popover will avoid this space when laying out.
 * @param {DOMRect} [params.clientRect] The area within that range that the arrow
 * should point at. Mostly relevant for when target text spans across multiple
 * lines; defaults to boundingClientRect if not provided.
 * @param {"horizontal-tb" | "vertical-rl" | "vertical-lr"} params.sourceTextWritingMode
 * @param {"horizontal-tb" | "vertical-rl" | "vertical-lr"} params.popoverWritingMode
 * @param {{ width: number; height: number }} params.popoverPreferredSize
 * @param {{ breadth: number; length: number }} params.arrowSize
 * @param {number} params.popoverMinimumInlineSize The minimum inline size a
 * suggested solution should have.
 * @param {number} params.popoverMinimumBlockSize The minimum block size a
 * suggested solution should have.
 * @param {number} params.popoverInsetSize
 * @param {(params: { maxInlineSize?: number }) => { width: number; height: number; }} params.getPopoverPreferredSize
 */
function calculatePopoverLayout(params) {
  const {
    boundingClientRect,
    clientRect = boundingClientRect,
    sourceTextWritingMode,
    popoverWritingMode,
    popoverPreferredSize,
    popoverInsetSize,
    popoverMinimumInlineSize,
    popoverMinimumBlockSize,
  } = params;

  console.log('calculatePopoverLayout', {
    clientRect,
    boundingClientRect,
    popoverPreferredSize,
  });

  /**
   * The order of preference as to where the popover should be placed relative
   * to the content to avoid downstream (not yet read) text, if multiple
   * solutions satisfy.
   * @type {Array<'above' | 'below' | 'on the left' | 'on the right'>}
   */
  const preferenceOrder =
    sourceTextWritingMode === 'horizontal-tb'
      ? ['below', 'above', 'on the left', 'on the right']
      : [
          ...(sourceTextWritingMode === 'vertical-rl'
            ? ['on the left', 'on the right']
            : ['on the right', 'on the left']),
          'above',
          'below',
        ];
  console.log('preferenceOrder', { preferenceOrder, sourceTextWritingMode });

  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;

  const above = calculatePopoverLayoutForPlacement({
    ...params,
    viewportWidth,
    viewportHeight,
    popoverPlacement: 'above',
  });
  const below = calculatePopoverLayoutForPlacement({
    ...params,
    viewportWidth,
    viewportHeight,
    popoverPlacement: 'below',
  });
  const toLeft = calculatePopoverLayoutForPlacement({
    ...params,
    viewportWidth,
    viewportHeight,
    popoverPlacement: 'on the left',
  });
  const toRight = calculatePopoverLayoutForPlacement({
    ...params,
    viewportWidth,
    viewportHeight,
    popoverPlacement: 'on the right',
  });

  const sorted = preferenceOrder
    .map(preference => {
      switch (preference) {
        case 'above':
          return above;
        case 'below':
          return below;
        case 'on the left':
          return toLeft;
        case 'on the right':
          return toRight;
      }
    })
    .sort((a, b) => {
      // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
      const A_BEFORE_B = -1;
      const NO_CHANGE = 0;
      const B_BEFORE_A = 1;

      // If one of the two has an arrow out of bounds, sort the one whose arrow
      // is in bounds to the front.
      //
      // If they both have an arrow out of bounds, continue to the next check.
      if (a.arrow.x < popoverInsetSize || a.arrow.y < popoverInsetSize) {
        if (b.arrow.x >= popoverInsetSize || b.arrow.y >= popoverInsetSize) {
          console.log('Case 1a: sorting B_BEFORE_A', { a, b });
          return B_BEFORE_A;
        } else {
          // They're both out of bounds. We could sort by the one that's least
          // out of bounds, or just invest our time improving the layout
          // algorithm instead.
        }
      } else if (b.arrow.x < popoverInsetSize || b.arrow.y < popoverInsetSize) {
        console.log('Case 1b: sorting A_BEFORE_B', { a, b });
        return A_BEFORE_B;
      }

      const aFitsAvailableArea =
        a.popover.width <= a.popover.maxWidth &&
        a.popover.height <= a.popover.maxHeight;
      const bFitsAvailableArea =
        b.popover.width <= b.popover.maxWidth &&
        b.popover.height <= b.popover.maxHeight;

      if (aFitsAvailableArea && !bFitsAvailableArea) {
        console.log('Case 2a: sorting A_BEFORE_B', { a, b });
        return A_BEFORE_B;
      }

      if (bFitsAvailableArea && !aFitsAvailableArea) {
        console.log('Case 2b: sorting B_BEFORE_A', { a, b });
        return B_BEFORE_A;
      }

      const aInlineSize =
        popoverWritingMode === 'horizontal-tb'
          ? Math.min(a.popover.width, a.popover.maxWidth)
          : Math.min(a.popover.height, a.popover.maxHeight);
      const bInlineSize =
        popoverWritingMode === 'horizontal-tb'
          ? Math.min(b.popover.width, b.popover.maxWidth)
          : Math.min(b.popover.height, b.popover.maxHeight);
      const aBlockSize =
        popoverWritingMode === 'horizontal-tb'
          ? Math.min(a.popover.height, a.popover.maxHeight)
          : Math.min(a.popover.width, a.popover.maxWidth);
      const bBlockSize =
        popoverWritingMode === 'horizontal-tb'
          ? Math.min(b.popover.height, b.popover.maxHeight)
          : Math.min(b.popover.width, b.popover.maxWidth);

      const aIsAdequatelyLargeInline = aInlineSize >= popoverMinimumInlineSize;
      const bIsAdequatelyLargeInline = bInlineSize >= popoverMinimumInlineSize;

      if (aIsAdequatelyLargeInline && !bIsAdequatelyLargeInline) {
        return A_BEFORE_B;
      }

      if (bIsAdequatelyLargeInline && !aIsAdequatelyLargeInline) {
        return B_BEFORE_A;
      }

      const aIsAdequatelyLargeBlock = aBlockSize >= popoverMinimumBlockSize;
      const bIsAdequatelyLargeBlock = bBlockSize >= popoverMinimumBlockSize;

      if (aIsAdequatelyLargeBlock && !bIsAdequatelyLargeBlock) {
        return A_BEFORE_B;
      }

      if (bIsAdequatelyLargeBlock && !aIsAdequatelyLargeBlock) {
        return B_BEFORE_A;
      }

      console.log('Case 3: sorting NO_CHANGE', { a, b });

      return NO_CHANGE;
    });

  return {
    best: sorted[0],
    sorted,
    above,
    below,
    toLeft,
    toRight,
  };
}

/**
 * @param {Parameters<typeof calculatePopoverLayout>[0] & { popoverPlacement: 'above' | 'below' | 'on the left' | 'on the right'; viewportWidth: number; viewportHeight: number; }} params
 */
function calculatePopoverLayoutForPlacement(params) {
  const {
    boundingClientRect,
    clientRect = boundingClientRect,
    popoverWritingMode,
    popoverPreferredSize,
    getPopoverPreferredSize,
    arrowSize,
    popoverInsetSize,
    popoverPlacement,
    viewportWidth,
    viewportHeight,
  } = params;

  /**
   * There are cases where the popover is able to satisfy its preferred block
   * size just fine, but not its preferred inline size. This can make the block
   * size meaningless, because it referred to a larger inline size and so may
   * now be too small and need to scroll.
   *
   * So here, we perform yet another layout pass if the given popoverPlacement
   * can't satisfy the desired inline size.
   *
   * TODO: these typings are not resolving, probably because they're
   * self-referential.
   *
   * @param {ReturnType<typeof calculatePopoverLayoutForPlacement>} provisionalLayout
   * @returns {{ type: "unchanged" | "updated", layout: ReturnType<typeof calculatePopoverLayoutForPlacement> }}
   */
  const handleInsufficientInlineSpace = provisionalLayout => {
    const { width, height, maxWidth, maxHeight } = provisionalLayout.popover;

    if (
      popoverWritingMode === 'horizontal-tb'
        ? width > maxWidth
        : height > maxHeight
    ) {
      // Lay out again
      const popoverPreferredSize = getPopoverPreferredSize({
        maxInlineSize:
          popoverWritingMode === 'horizontal-tb'
            ? Math.floor(maxWidth)
            : Math.floor(maxHeight),
      });

      // Avoid infinite loop
      if (
        popoverWritingMode === 'horizontal-tb'
          ? popoverPreferredSize.width >= width
          : popoverPreferredSize.height >= height
      ) {
        return { type: 'unchanged', layout: provisionalLayout };
      }

      return {
        type: 'updated',
        layout: calculatePopoverLayoutForPlacement({
          ...params,
          popoverPreferredSize,
        }),
      };
    }

    return { type: 'unchanged', layout: provisionalLayout };
  };

  switch (popoverPlacement) {
    case 'above': {
      //        horizontal-tb ltr               horizontal-tb rtl
      // ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓   ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
      // ┃                            ┃   ┃                            ┃
      // ┃    ┏━━━━━━━┓               ┃   ┃                ┏━━━━━━━┓   ┃
      // ┃    ┃ abc   ┃               ┃   ┃                ┃   cba ┃   ┃
      // ┃    ┃ defg  ┃               ┃   ┃                ┃  gfed ┃   ┃
      // ┃    ┣━━━━━━━┛               ┃   ┃                ┗━━━━━━━┫   ┃
      // ┃    ⏷                       ┃   ┃                        ⏷   ┃
      // ┃ abcdefghij                 ┃   ┃                 jihgfedcba ┃
      // ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛   ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
      //
      //          vertical-lr                      vertical-rl
      // ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓   ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
      // ┃ a h                        ┃   ┃                        h a ┃
      // ┃ b ┏━━━━━━━┓                ┃   ┃                ┏━━━━━━━┓ b ┃
      // ┃ c ┃ ac    ┃                ┃   ┃                ┃    ca ┃ c ┃
      // ┃ d ┃ b     ┃                ┃   ┃                ┃     b ┃ d ┃
      // ┃ e ┣━━━━━━━┛                ┃   ┃                ┗━━━━━━━┫ e ┃
      // ┃ f ⏷                        ┃   ┃                        ⏷ f ┃
      // ┃ g n                        ┃   ┃                        n g ┃
      // ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛   ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
      const above = {
        popoverPlacement: 'above',
        // FIXME: would be nice to ensure the arrow stays within
        //        popoverInsetSize, as otherwise, when the arrow is at the
        //        viewport edge, the popover can detach from it.
        arrow: {
          x: clientRect.left + clientRect.width / 2 - arrowSize.breadth / 2,
          y: clientRect.top - arrowSize.length,
          width: arrowSize.breadth,
          height: arrowSize.length,
        },
        popover: {
          x: popoverInsetSize,
          y: popoverInsetSize,
          width: popoverPreferredSize.width,
          height: popoverPreferredSize.height,
          maxWidth: viewportWidth - popoverInsetSize * 2,
          maxHeight:
            boundingClientRect.top - popoverInsetSize - arrowSize.length,
        },
      };

      const result = handleInsufficientInlineSpace(above);
      if (result.type === 'updated') {
        return result.layout;
      }

      const aboveAdjusted = {
        popoverPlacement: 'above',
        arrow: above.arrow,
        popover: alignAndJustify({
          popoverPlacement: 'above',
          horizontalAlign: 'right',
          verticalAlign: 'bottom',
          constraints: above.popover,
          arrowRect: above.arrow,
          arrowOverhang: 20,
        }),
      };

      return aboveAdjusted;
    }
    case 'below': {
      //        horizontal-tb ltr               horizontal-tb rtl
      // ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓   ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
      // ┃ abcdefghij                 ┃   ┃                 jihgfedcba ┃
      // ┃    ⏶                       ┃   ┃                        ⏶   ┃
      // ┃    ┣━━━━━━━┓               ┃   ┃                ┏━━━━━━━┫   ┃
      // ┃    ┃ abc   ┃               ┃   ┃                ┃   cba ┃   ┃
      // ┃    ┃ defg  ┃               ┃   ┃                ┃  gfed ┃   ┃
      // ┃    ┗━━━━━━━┛               ┃   ┃                ┗━━━━━━━┛   ┃
      // ┃                            ┃   ┃                            ┃
      // ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛   ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
      //
      //          vertical-lr                      vertical-rl
      // ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓   ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
      // ┃ a i                        ┃   ┃                        i a ┃
      // ┃ b ⏶                        ┃   ┃                        ⏶ b ┃
      // ┃ c ┣━━━━━━━┓                ┃   ┃                ┏━━━━━━━┫ c ┃
      // ┃ d ┃ ac    ┃                ┃   ┃                ┃    ca ┃ d ┃
      // ┃ e ┃ b     ┃                ┃   ┃                ┃     b ┃ e ┃
      // ┃ f ┗━━━━━━━┛                ┃   ┃                ┗━━━━━━━┛ f ┃
      // ┃ g o                        ┃   ┃                        o g ┃
      // ┃ h p                        ┃   ┃                        p h ┃
      // ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛   ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
      const below = {
        popoverPlacement: 'below',
        arrow: {
          x: clientRect.left + clientRect.width / 2 - arrowSize.breadth / 2,
          y: clientRect.bottom,
          width: arrowSize.breadth,
          height: arrowSize.length,
        },
        popover: {
          x: popoverInsetSize,
          y: boundingClientRect.bottom + arrowSize.length,
          width: popoverPreferredSize.width,
          height: popoverPreferredSize.height,
          maxWidth: viewportWidth - popoverInsetSize * 2,
          maxHeight:
            viewportHeight -
            boundingClientRect.bottom -
            popoverInsetSize -
            arrowSize.length,
        },
      };

      const result = handleInsufficientInlineSpace(below);
      if (result.type === 'updated') {
        return result.layout;
      }

      const belowAdjusted = {
        popoverPlacement: 'below',
        arrow: below.arrow,
        popover: alignAndJustify({
          popoverPlacement: 'below',
          horizontalAlign: 'right',
          verticalAlign: 'top',
          constraints: below.popover,
          arrowRect: below.arrow,
          arrowOverhang: 20,
        }),
      };

      return belowAdjusted;
    }
    case 'on the left': {
      //        horizontal-tb ltr               horizontal-tb rtl
      // ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓   ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
      // ┃ abcdefghijklmnopqrstuvwxyz ┃   ┃ zyxwvutsrqponmlkjihgfedcba ┃
      // ┃ abcdefghijklmnopqrstuvwxyz ┃   ┃ zyxwvutsrqponmlkjihgfedcba ┃
      // ┃              ┏━━━━━━━┳⏵abc ┃   ┃              ┏━━━━━━━┳⏵cba ┃
      // ┃              ┃ abc   ┃ abc ┃   ┃              ┃   cba ┃ cba ┃
      // ┃              ┃ defg  ┃ abc ┃   ┃              ┃  gfed ┃ cba ┃
      // ┃              ┗━━━━━━━┛ abc ┃   ┃              ┗━━━━━━━┛ cba ┃
      // ┃                            ┃   ┃                            ┃
      // ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛   ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
      //
      //          vertical-lr                      vertical-rl
      // ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓   ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
      // ┃ a a a a a a a a a a a a a  ┃   ┃                          a ┃
      // ┃ b b b b b b b b b b b b b  ┃   ┃                          b ┃
      // ┃ c c c c c c c ┏━━━━━━━┳⏵c  ┃   ┃                ┏━━━━━━━┳⏵c ┃
      // ┃ d d d d d d d ┃ ac    ┃ d  ┃   ┃                ┃    ca ┃ d ┃
      // ┃ e e e e e e e ┃ b     ┃    ┃   ┃                ┃     b ┃ e ┃
      // ┃ f f f f f f f ┗━━━━━━━┛    ┃   ┃                ┗━━━━━━━┛ f ┃
      // ┃ g g g g g g g g g g g g    ┃   ┃                            ┃
      // ┃ h h h h h h h h h h h h    ┃   ┃                            ┃
      // ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛   ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
      const toLeft = {
        popoverPlacement: 'on the left',
        arrow: {
          x: clientRect.left - arrowSize.length,
          y: clientRect.top + clientRect.height / 2 - arrowSize.breadth / 2,
          width: arrowSize.length,
          height: arrowSize.breadth,
        },
        popover: {
          x: popoverInsetSize,
          y: popoverInsetSize,
          width: popoverPreferredSize.width,
          height: popoverPreferredSize.height,
          maxWidth:
            boundingClientRect.left - popoverInsetSize - arrowSize.length,
          maxHeight: viewportHeight - popoverInsetSize * 2,
        },
      };

      const result = handleInsufficientInlineSpace(toLeft);
      if (result.type === 'updated') {
        return result.layout;
      }

      const toLeftAdjusted = {
        popoverPlacement: 'on the left',
        arrow: toLeft.arrow,
        popover: alignAndJustify({
          popoverPlacement: 'on the left',
          horizontalAlign: 'right',
          verticalAlign: 'bottom',
          constraints: toLeft.popover,
          arrowRect: toLeft.arrow,
          arrowOverhang: 20,
        }),
      };
      return toLeftAdjusted;
    }
    case 'on the right': {
      //        horizontal-tb ltr               horizontal-tb rtl
      // ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓   ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
      // ┃ abcdefghijklmnopqrstuvwxyz ┃   ┃ zyxwvutsrqponmlkjihgfedcba ┃
      // ┃ abcdefghijklmnopqrstuvwxyz ┃   ┃ zyxwvutsrqponmlkjihgfedcba ┃
      // ┃ abc⏴┳━━━━━━━┓              ┃   ┃ zyx⏴┳━━━━━━━┓ lkjihgfedcba ┃
      // ┃ abc ┃ abc   ┃              ┃   ┃ zyx ┃ edcba ┃          cba ┃
      // ┃ abc ┃ defg  ┃              ┃   ┃ zyx ┃    gf ┃              ┃
      // ┃ abc ┗━━━━━━━┛              ┃   ┃ zyx ┗━━━━━━━┛              ┃
      // ┃                            ┃   ┃                            ┃
      // ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛   ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
      //
      //          vertical-lr                      vertical-rl
      // ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓   ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
      // ┃ a a                        ┃   ┃   a a a a a a  a a a a a a ┃
      // ┃ b b                        ┃   ┃   b b b b b b  b b b b b b ┃
      // ┃ c c ⏴┳━━━━━━━┓             ┃   ┃   c ⏴┳━━━━━━━┓ c c c c c c ┃
      // ┃ d d  ┃ ac    ┃             ┃   ┃   d  ┃    ca ┃ d d d d d d ┃
      // ┃ e e  ┃ b     ┃             ┃   ┃   e  ┃     b ┃ e e e e e e ┃
      // ┃ f f  ┗━━━━━━━┛             ┃   ┃      ┗━━━━━━━┛ f f f f f f ┃
      // ┃ g                          ┃   ┃     g g g g g  g g g g g g ┃
      // ┃ h                          ┃   ┃     h h h h h  h h h h h h ┃
      // ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛   ┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
      const toRightArrow = {
        x: clientRect.right,
        y: clientRect.top + clientRect.height / 2 - arrowSize.breadth / 2,
        width: arrowSize.length,
        height: arrowSize.breadth,
      };
      const toRight = {
        popoverPlacement: 'on the right',
        arrow: toRightArrow,
        popover: {
          // We have an interesting case with vertical-rl when a word flows onto
          // a new line such that the start of the word is clickable within the
          // viewport, yet the end of the word extends out of the viewport.
          // We've generally chosen to point at the end of the word, but in this
          // rare case it might make more sense to point at the start just to
          // stay within the viewport. However, it's okay to just do what's
          // easiest.
          x: Math.max(popoverInsetSize, toRightArrow.x + toRightArrow.width),
          y: popoverInsetSize,
          width: popoverPreferredSize.width,
          height: popoverPreferredSize.height,
          maxWidth:
            viewportWidth -
            boundingClientRect.right -
            popoverInsetSize -
            arrowSize.length,
          maxHeight: viewportHeight - popoverInsetSize * 2,
        },
      };

      const result = handleInsufficientInlineSpace(toRight);
      if (result.type === 'updated') {
        return result.layout;
      }

      const toRightAdjusted = {
        popoverPlacement: 'on the right',
        arrow: toRight.arrow,
        popover: alignAndJustify({
          popoverPlacement: 'on the right',
          horizontalAlign: 'left',
          verticalAlign: 'bottom',
          constraints: toRight.popover,
          arrowRect: toRight.arrow,
          arrowOverhang: 20,
        }),
      };
      return toRightAdjusted;
    }
  }
}

/**
 * Aligns the popover within its available space based on its preferred size and
 * orientation, with reference to the arrow element and any desired overhang.
 *
 * Expects to be given constraints where:
 * - x is the left limit of the viewport
 * - maxWidth is the right limit of the viewport
 * - y is the top limit of the viewport
 * - maxHeight is the bottom limit of the viewport
 * - width is the preferred width of the popover
 * - height is the preferred height of the popover
 *
 * @param {object} obj
 * @param {"left" | "right"} obj.horizontalAlign
 * @param {"top" | "bottom"} obj.verticalAlign
 * @param {{ x: number; y: number; width: number; height: number; }} obj.arrowRect
 * @param {number} obj.arrowOverhang
 * @param {{ x: number; y: number; width: number; height: number; maxWidth: number; maxHeight: number; }} obj.constraints
 * @param {'above' | 'below' | 'on the left' | 'on the right'} popoverPlacement
 */
function alignAndJustify({
  horizontalAlign,
  verticalAlign,
  arrowRect,
  arrowOverhang,
  constraints,
  popoverPlacement,
}) {
  const rightLimit = constraints.x + constraints.maxWidth;
  const bottomLimit = constraints.y + constraints.maxHeight;
  const solution = { ...constraints };

  switch (horizontalAlign) {
    case 'left': {
      solution.x = arrowRect.x + arrowRect.width;
      break;
    }
    case 'right': {
      const idealX = Math.max(constraints.x, arrowRect.x - arrowOverhang);
      const availableWidthWithIdealX = rightLimit - idealX;
      solution.x =
        constraints.width > availableWidthWithIdealX
          ? Math.max(
              rightLimit - constraints.width,
              rightLimit - constraints.maxWidth,
            )
          : idealX;
      break;
    }
  }

  switch (verticalAlign) {
    case 'top': {
      if (popoverPlacement !== 'below') {
        console.warn(
          `[alignAndJustify] verticalAlign: "bottom" only implemented for popoverPlacement "below".`,
        );
        break;
      }
      solution.y =
        popoverPlacement === 'below'
          ? arrowRect.y + arrowRect.height
          : arrowRect.y + arrowRect.height + arrowOverhang;
      break;
    }
    case 'bottom': {
      if (popoverPlacement === 'below') {
        console.warn(
          `[alignAndJustify] verticalAlign: "bottom" not implemented for popoverPlacement "below".`,
        );
        break;
      }
      const idealY = Math.max(
        constraints.y,
        popoverPlacement === 'above'
          ? arrowRect.y - constraints.height
          : arrowRect.y - arrowOverhang,
      );
      const availableHeightWithIdealY = bottomLimit - idealY;
      solution.y =
        constraints.height > availableHeightWithIdealY
          ? Math.max(
              bottomLimit - constraints.height,
              bottomLimit - constraints.maxHeight,
            )
          : idealY;
      break;
    }
  }

  return solution;
}

/**
 * Wraps any direct bare text node children in a `<ruby>` with `<rb>`:
 *
 * ```diff
 * - <ruby>明日<rt>あした</rt></ruby>
 * + <ruby><rb>明日</rb><rt>あした</rt></ruby>
 * ```
 *
 * @param root {Element}
 */
function wrapRubyBaseTextsWithRb(root) {
  for (const ruby of root.querySelectorAll('ruby')) {
    for (const childNode of ruby.childNodes) {
      if (childNode.nodeName !== '#text') {
        continue;
      }
      const rb = document.createElement('rb');
      ruby.replaceChild(rb, childNode);
      rb.appendChild(childNode);
    }
  }
}

/**
 * Prepend a prelude and append a postlude into the <body>.
 */
function insertNavigationButtons(body) {
  // TODO: style Previous & Next as primary, and the Jump buttons as secondary.
  const commonStyles =
    'display: flex; justify-content: center; align-items: center; column-gap: 8px;';

  const prelude = `
<div id="paranovel-prelude" style="${commonStyles} padding-block-end: 16px;">
  <button id="paranovel-previous" type="button" style="writing-mode: horizontal-tb;">Previous</button>
  <button id="paranovel-end" type="button" style="writing-mode: horizontal-tb;">Jump to end</button>
</div>
  `.trim();

  const postlude = `
<div id="paranovel-postlude" style="${commonStyles} padding-block-start: 16px;">
  <button id="paranovel-start" type="button" style="writing-mode: horizontal-tb;">Return to start</button>
  <button id="paranovel-next" type="button" style="writing-mode: horizontal-tb;">Next</button>
</div>
  `.trim();

  for (const html of [postlude, prelude]) {
    const template = document.createElement('template');
    template.innerHTML = html;
    const dom = template.content.firstChild;

    switch (dom.id) {
      case 'paranovel-prelude': {
        const prev = dom.querySelector('#paranovel-previous');
        prev.onclick = event => {
          window.ReactNativeWebView.postMessage(
            JSON.stringify({
              type: 'navigation-request',
              value: 'prev',
              currentHref: location.href,
            }),
          );
        };

        const end = dom.querySelector('#paranovel-end');
        end.onclick = event => {
          document.body.scrollIntoView({
            block: 'end',
            inline: 'end',
            behavior: 'instant',
          });
        };

        body.prepend(dom);
        break;
      }
      case 'paranovel-postlude': {
        const next = dom.querySelector('#paranovel-next');
        next.onclick = event => {
          window.ReactNativeWebView.postMessage(
            JSON.stringify({
              type: 'navigation-request',
              value: 'next',
              currentHref: location.href,
            }),
          );
        };

        const start = dom.querySelector('#paranovel-start');
        start.onclick = event => {
          document.body.scrollIntoView({
            block: 'start',
            inline: 'start',
            behavior: 'instant',
          });
        };

        body.append(dom);
        break;
      }
    }
  }
}

function log(message) {
  window.ReactNativeWebView.postMessage(
    JSON.stringify({ type: 'log', message }),
  );
}

/**
 * @param {MouseEvent} event
 */
async function onClickDocument(event) {
  const { x, y, target } = event;

  if (
    document.getElementById('paranovel-popover')?.contains(target) ||
    document.getElementById('paranovel-prelude')?.contains(target) ||
    document.getElementById('paranovel-postlude')?.contains(target)
  ) {
    // Don't attempt to look up text for any clicks within Paranovel UI
    // elements.
    return;
  }

  const caretRange = document.caretRangeFromPoint(x, y);
  if (!caretRange) {
    log('❌ no caret range');
    return;
  }

  const surroundingText = getSurroundingText(caretRange);
  if (!surroundingText) {
    log('❌ no surrounding text');
    return;
  }
  console.log(surroundingText);
  const {
    blockBaseText,
    closestBlock,
    offsetOfTargetBaseTextIntoBlockBaseText,
    targetNode,
  } = surroundingText;

  __paranovelState.wordHighlight.clear();

  const id = __paranovelState.tokenizationPromiseCount++;

  let response;
  try {
    response = await new Promise((resolve, reject) => {
      __paranovelState.tokenizationPromiseHandlers[id] = { resolve, reject };

      // Promise is settled by onNovelViewMessage calling resolve/reject
      window.ReactNativeWebView.postMessage(
        JSON.stringify({
          type: 'tokenize',
          id,
          blockBaseText,
          offset: offsetOfTargetBaseTextIntoBlockBaseText,
        }),
      );
    });
  } catch (error) {
    console.error('Tokenize Promise rejected with error', error);
    log(
      `❌ Tokenize Promise rejected${
        error instanceof Error ? ` with error: "${error.message}"` : '.'
      }`,
    );
  } finally {
    delete __paranovelState.tokenizationPromiseHandlers[id];
  }

  const {
    dictionaryForm,
    tokenLength,
    offsetOfTargetTokenIntoBlockBaseText,
    offsetOfTargetCharacterIntoBlockBaseText,
  } = response;
  log(
    `📖 dictionaryForm: "${dictionaryForm}"; tokenOffset: ${offsetOfTargetTokenIntoBlockBaseText}, characterOffset: ${offsetOfTargetCharacterIntoBlockBaseText}; length: ${tokenLength}`,
  );

  const tokenRange = getRangeFromOffsetIntoBlockBaseText({
    blockElement: closestBlock,
    blockBaseText,
    startOffset: offsetOfTargetTokenIntoBlockBaseText,
    endOffset: offsetOfTargetTokenIntoBlockBaseText + tokenLength,
  });
  if (!tokenRange) {
    return;
  }

  // If we're inside a base text of a <ruby> (whether a text node or an <rb>),
  // and the selection range terminates at the end of that base text, then
  // search for the matching <rt> and extend the highlight to include that.
  const { endContainer, endOffset } = tokenRange;
  if (
    (endContainer instanceof CharacterData &&
      endOffset === endContainer.data.length) ||
    endOffset === endContainer.childNodes.length
  ) {
    const endContainerElement =
      endContainer instanceof Element
        ? endContainer
        : endContainer.parentElement;
    const endContainerRuby = endContainerElement?.closest('ruby');
    if (endContainerRuby) {
      /** @type {HTMLElement | undefined} */
      let correspondingRt;
      for (const node of traverseFollowingText(
        endContainerElement,
        'next',
        endContainerRuby,
      )) {
        if (node.nodeName.toUpperCase() === 'RT') {
          correspondingRt = node;
          break;
        }
      }
      if (correspondingRt) {
        tokenRange.setEnd(correspondingRt, correspondingRt.childNodes.length);
      }
    }
  }

  __paranovelState.wordHighlight.add(tokenRange);
  const boundingClientRect = tokenRange.getBoundingClientRect();
  const endContainerElement =
    tokenRange.endContainer instanceof Element
      ? tokenRange.endContainer
      : tokenRange.endContainer.parentElement;
  const clientRects = tokenRange.getClientRects();
  const idealClientRectForArrow = getIdealClientRectForArrow(tokenRange);
  console.log('onClickDocument', {
    boundingClientRect,
    tokenRange,
    tokenRangeRect: tokenRange.getBoundingClientRect(),
    tokenRangeRects: tokenRange.getClientRects(),
    endContainerElement,
    endContainerRect: endContainerElement.getBoundingClientRect(),
    endContainerRects: endContainerElement.getClientRects(),
    clientRects,
    idealClientRectForArrow,
  });
  window.tokenRange = tokenRange;
  const writingMode =
    endContainerElement?.computedStyleMap().get('writing-mode').value ??
    'horizontal-tb';

  log(
    `🔎 Looking up term "${dictionaryForm}" with boundingClientRect ${JSON.stringify(
      boundingClientRect.toJSON(),
    )} and writingMode "${writingMode}"`,
  );
  lookUpTerm({
    dictionaryForm,
    boundingClientRect,
    clientRect: idealClientRectForArrow,
    writingMode,
  });
}

/**
 * Gets the ideal client rect that the arrow should point at. If the tokenRange
 * spans multiple lines, this is a rect encompassing both the base/<rb> and the
 * <rt>. Otherwise, it's just the boundingClientRect for the whole tokenRange.
 *
 * @param {Range} tokenRange
 * @param {"horizontal-tb" | "vertical-rl" | "vertical-lr"} writingMode
 */
function getIdealClientRectForArrow(tokenRange, writingMode) {
  const clientRects = tokenRange.getClientRects();

  // FIXME: this automatically assumes that the selection spans multiple lines.
  // Instead of pre-emptively choosing the last one, we should first check
  // whether penultimateClientRect.x differs from the first clientRect.

  // firstClientRect *should* represent a base/<rb>, assuming it's legal.
  const firstClientRect = clientRects[0];
  const lastClientRect = clientRects[clientRects.length - 1];
  if (!firstClientRect || !lastClientRect) {
    return tokenRange.getBoundingClientRect();
  }

  // If the final clientRect doesn't belong to an <rt>, then we can use it as-is
  // rather than joining it together with its corresponding base text's
  // clientRect.
  if (tokenRange.endContainer.nodeName.toUpperCase() !== 'RT') {
    const isOnSameLine =
      writingMode === 'horizontal-tb'
        ? lastClientRect.y === firstClientRect.y
        : lastClientRect.x === firstClientRect.x;

    return isOnSameLine ? tokenRange.getBoundingClientRect() : lastClientRect;
  }

  // Otherwise, we must combine the clientRect for the <rt> with that of the
  // preceding clientRect (which will correspond to either an <rb> or a text
  // node).

  const penultimateClientRect = clientRects[clientRects.length - 2];
  if (!penultimateClientRect) {
    return tokenRange.getBoundingClientRect();
  }

  const x = Math.min(penultimateClientRect.x, lastClientRect.x);
  const y = Math.min(penultimateClientRect.y, lastClientRect.y);

  const finalBaseAndRtRect = DOMRect.fromRect({
    x,
    y,
    width: Math.max(penultimateClientRect.right, lastClientRect.right) - x,
    height: Math.max(penultimateClientRect.bottom, lastClientRect.bottom) - y,
  });

  const isOnSameLine =
    writingMode === 'horizontal-tb'
      ? finalBaseAndRtRect.y === firstClientRect.y
      : finalBaseAndRtRect.x === firstClientRect.x;

  return isOnSameLine ? tokenRange.getBoundingClientRect() : finalBaseAndRtRect;
}

function getViewportScrollLeft() {
  return (
    document.body.scrollWidth -
    Math.abs(document.body.scrollLeft) -
    window.innerWidth
  );
}
function getViewportScrollTop() {
  return (
    document.body.scrollHeight -
    Math.abs(document.body.scrollTop) -
    window.innerHeight
  );
}

/**
 *
 * @param {object} obj
 * @param {string} obj.dictionaryForm
 * @param {DOMRect} obj.boundingClientRect
 * @param {DOMRect} [obj.clientRect]
 * @param {"horizontal-tb" | "vertical-rl" | "vertical-lr"} obj.writingMode
 */
async function lookUpTerm({
  dictionaryForm,
  boundingClientRect,
  clientRect = boundingClientRect,
  writingMode,
}) {
  const id = __paranovelState.tokenizationPromiseCount++;

  /** @type {string} */
  let response;
  try {
    response = await new Promise((resolve, reject) => {
      __paranovelState.tokenizationPromiseHandlers[id] = { resolve, reject };

      // Promise is settled by onNovelViewMessage calling resolve/reject
      window.ReactNativeWebView.postMessage(
        JSON.stringify({
          type: 'lookUpTerm',
          term: dictionaryForm,
          id,
        }),
      );
    });
  } catch (error) {
    console.error('lookUpTerm Promise rejected with error', error);
    log(
      `❌ lookUpTerm Promise rejected${
        error instanceof Error ? ` with error: "${error.message}"` : '.'
      }`,
    );
    return;
  } finally {
    delete __paranovelState.tokenizationPromiseHandlers[id];
  }

  updatePopover({
    boundingClientRect,
    clientRect,
    writingMode,
    results: response,
    display: 'block',
  });
}

function getRangeFromOffsetIntoBlockBaseText({
  blockElement,
  blockBaseText,
  startOffset,
  endOffset,
}) {
  if (!(blockElement instanceof HTMLElement)) {
    throw new TypeError('Expected blockElement to be an HTML Element.');
  }

  if (startOffset < 0 || startOffset > blockBaseText.length) {
    throw new DOMException(
      'The index is not in the allowed range.',
      'IndexSizeError',
    );
  }

  const rangeLength = endOffset - startOffset;

  let offset = 0;
  const range = document.createRange();
  let foundStartOffset = false;
  let prevNode = null;
  for (const node of traverseBaseText(blockElement)) {
    const actual = node.textContent;
    const expected = blockBaseText.slice(offset, offset + actual.length);
    if (actual !== expected) {
      throw new Error(
        'Expected to be able to reproduce the originally extracted base text when retraversing the same block.',
      );
    }

    // If the offsets lie within this node, set the range accordingly.
    //
    // When there are multiple possible solutions due to the range being on a
    // boundary between two nodes, prefer to keep the range as small as
    // possible.
    //
    // Note that we blindly assume a forward range (startOffset < endOffset).

    // For startOffset, prefer the following node (thus >)
    if (!foundStartOffset && offset + actual.length > startOffset) {
      const offsetWithinNode = startOffset - offset;
      range.setStart(node, offsetWithinNode);
      foundStartOffset = true;
    }

    // For endOffset, prefer the current node (thus >=)
    if (foundStartOffset && offset + actual.length >= endOffset) {
      const offsetWithinNode = endOffset - offset;
      range.setEnd(node, offsetWithinNode);
      return range;
    }

    offset += actual.length;
    prevNode = node;
  }

  return null;
}

function getSurroundingText(range) {
  const { startContainer: targetNode, startOffset: targetOffset } = range;
  if (!(targetNode instanceof Text)) {
    return;
  }

  const element = targetNode.parentElement;
  if (!element) {
    return;
  }

  const closestRuby = element.closest('ruby');
  const blockElementsSelector =
    'address,article,aside,blockquote,canvas,dd,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hr,li,main,nav,noscript,ol,p,pre,section,table,tfoot,ul,video';
  const closestBlock = element.closest(blockElementsSelector);

  let leadingBaseText = '';
  let targetBaseText = '';
  let trailingBaseText = '';
  for (const { baseTextContent, stage } of traverseBlock(targetNode)) {
    switch (stage) {
      case BlockTraversalStage.leading: {
        leadingBaseText = `${baseTextContent}${leadingBaseText}`;
        break;
      }
      case BlockTraversalStage.target: {
        targetBaseText = baseTextContent;
        break;
      }
      case BlockTraversalStage.trailing: {
        trailingBaseText = `${trailingBaseText}${baseTextContent}`;
        break;
      }
    }
  }

  const offsetOfTargetBaseTextIntoBlockBaseText =
    leadingBaseText.length + (closestRuby ? 0 : targetOffset);
  const blockBaseText = leadingBaseText + targetBaseText + trailingBaseText;

  return {
    leadingBaseText,
    targetNode,
    targetBaseText,
    targetBaseTextSliced: targetBaseText.slice(
      offsetOfTargetBaseTextIntoBlockBaseText,
    ),
    trailingBaseText,
    closestBlock,
    blockBaseText,
    offsetOfTargetBaseTextIntoBlockBaseText,
  };
}

function* traverseBlock(textNode) {
  if (!(textNode instanceof Text)) {
    return;
  }

  const element = textNode.parentElement;
  if (!element) {
    return;
  }

  const closestRuby = element.closest('ruby');
  const pivot = closestRuby ?? textNode;
  const blockElementsSelector =
    'address,article,aside,blockquote,canvas,dd,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hr,li,main,nav,noscript,ol,p,pre,section,table,tfoot,ul,video';
  const closestBlock = element.closest(blockElementsSelector);

  for (const node of traverseFollowingText(pivot, 'previous', closestBlock)) {
    const baseTextContent = getBaseTextContent(node);
    yield { baseTextContent, stage: BlockTraversalStage.leading };
  }

  const targetBaseText = getBaseTextContent(pivot);
  yield { baseTextContent: targetBaseText, stage: BlockTraversalStage.target };

  for (const node of traverseFollowingText(pivot, 'next', closestBlock)) {
    const baseTextContent = getBaseTextContent(node);
    yield { baseTextContent, stage: BlockTraversalStage.trailing };
  }
}

const BlockTraversalStage = {
  leading: 0,
  target: 1,
  trailing: 2,
};

function getFollowingText(
  node,
  direction,
  untilAncestor,
  blocklist = element => false,
) {
  let followingText = '';

  if (direction === 'next') {
    for (const node of traverseFollowingText(
      node,
      direction,
      untilAncestor,
      blocklist,
    )) {
      const baseTextContent = getBaseTextContent(node);
      followingText = `${followingText}${baseTextContent}`;
    }
  } else {
    for (const node of traverseFollowingText(
      node,
      direction,
      untilAncestor,
      blocklist,
    )) {
      const baseTextContent = getBaseTextContent(node);
      followingText = `${baseTextContent}${followingText}`;
    }
  }

  return followingText;
}

/**
 * @param {Node} node
 * @param {"prev" | "next"} direction
 * @param {Node} [untilAncestor]
 * @param {(element: Element) => boolean} blocklist
 */
function* traverseFollowingText(
  node,
  direction,
  untilAncestor,
  blocklist = element => false,
) {
  let parent = node.parentElement;
  let sibling = direction === 'next' ? node.nextSibling : node.previousSibling;
  while (true) {
    // If we've reached the end of the run, climb up to the parent and continue.
    while (!sibling) {
      if (!parent || parent === untilAncestor) {
        return;
      }

      sibling =
        direction === 'next' ? parent.nextSibling : parent.previousSibling;

      // If we've walked into a blocklisted sibling, consider it the end of the
      // line and climb up further.
      if (blocklist(sibling)) {
        sibling = null;
      }

      parent = parent.parentElement;
    }

    yield sibling;

    sibling =
      direction === 'next' ? sibling.nextSibling : sibling.previousSibling;
  }
}

function* traverseBaseText(node) {
  const treeWalker = document.createTreeWalker(
    node,
    // We need SHOW_ELEMENT to filter out all <rt> subtrees, while the payload
    // we're actually interested in is SHOW_TEXT.
    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT,
    node => {
      switch (node.nodeName) {
        // Element nodeNames are uppercase in HTML, yet lowercase in XHTML
        case 'rt':
        case 'RT':
          return NodeFilter.FILTER_REJECT;
        case '#text':
          return NodeFilter.FILTER_ACCEPT;
        default:
          return NodeFilter.FILTER_SKIP;
      }
    },
  );

  // Make the traversal inclusive of the target node.
  if (node.nodeName === '#text') {
    yield node;
  }

  let nextNode;
  while ((nextNode = treeWalker.nextNode())) {
    yield nextNode;
  }
}

// Warning: does not return empty strings if called directly on/inside <rt>/<rp>
function getBaseTextContent(node) {
  let baseTextContent = '';
  for (const textNode of traverseBaseText(node)) {
    baseTextContent = `${baseTextContent}${textNode.textContent}`;
  }
  return baseTextContent;
}

const __paranovelState = {
  wordHighlight: new Highlight(),
  tokenizationPromiseCount: 0,
  tokenizationPromiseHandlers: {},
};

CSS.highlights.set('word', __paranovelState.wordHighlight);

insertNavigationButtons(document.body);
document.addEventListener('click', onClickDocument);
