// Prevent restoring the last-scrolled position from a previous session.
history.scrollRestoration = 'manual';

{
  // Insert a viewport meta tag
  const meta = document.createElement('meta');
  meta.name = 'viewport';
  meta.content = 'width=device-width, initial-scale=1, user-scalable=no';
  document.head.appendChild(meta);
}

// Although <rb> is a deprecated element, on WebKit, the CSS Custom Highlight
// API simply doesn't highlight the bare text nodes, so we apply this change as
// a workaround.
wrapRubyBaseTextsWithRb(document.body);

/**
 * @param {object} obj
 * @param {DOMRect} obj.sourceRect The bounding client rect for the range that
 * is highlighted (that the popover should avoid).
 * @param {"horizontal-tb" | "vertical-rl" | "vertical-lr"} obj.writingMode the
 * writing mode of the range that has been highlighted (informing where the
 * popover should prefer to align to if the source rect is particularly large,
 * e.g. due to spanning two lines).
 * @param {Array<import("../../utils/look-up-term").LookupResult>} [obj.results]
 * @param {"block" | "none"} obj.display
 */
function updatePopover({ sourceRect, writingMode, display, results }) {
  const { x, y, width } = sourceRect;
  const popover =
    document.getElementById('paranovel-popover') ??
    document.createElement('div');
  popover.id = 'paranovel-popover';

  if (!popover.isConnected) {
    document.body.prepend(popover);
  }

  const popoverLayout = calculatePopoverLayout({
    permittedArrowDirections:
      writingMode === 'horizontal-tb'
        ? [
            PopoverArrowDirection.down,
            PopoverArrowDirection.up,
            PopoverArrowDirection.left,
            PopoverArrowDirection.right,
          ]
        : [
            ...(writingMode === 'vertical-rl'
              ? [PopoverArrowDirection.left, PopoverArrowDirection.right]
              : [PopoverArrowDirection.right, PopoverArrowDirection.left]),
            PopoverArrowDirection.down,
            PopoverArrowDirection.up,
          ],
    safeAreaEdgeInsets: {
      left: 8,
      top: 8,
      bottom: 8,
      right: 8,
    },
    sourceRect,
    backdropWidth: window.innerWidth,
    backdropHeight: window.innerHeight,
    preferredWidth: 300,
    preferredHeight: 400,

    arrowBreadth: 30,
    arrowLength: 15,
    cornerWidth: 30,
    borderRadius: 15,
  });

  log(`ℹ️ Got popoverLayout ${JSON.stringify(popoverLayout)}`);

  popover.style.left = `${popoverLayout.popover.x}px`;
  popover.style.top = `${popoverLayout.popover.y}px`;
  popover.style.width = 'auto';
  popover.style.maxWidth = `${popoverLayout.popover.width}px`;
  popover.style.height = 'auto';
  popover.style.maxHeight = `${popoverLayout.popover.height}px`;
  popover.style.display = display;

  // UI ported over from Paranovel v1's `src/screens/novel/DictView.tsx`.
  // The container here maps to DictView's `ScrollView`, but we hoist its styles
  // up to #paranovel-popover's CSS declaration instead.

  const defaultFontSize = '14px';

  const container = document.createDocumentFragment();

  if (!results?.length) {
    const p = document.createElement('p');
    p.style.margin = '0';
    p.style.color = 'white';
    p.style.fontSize = defaultFontSize;
    p.textContent = 'No results.';
    container.appendChild(p);
    popover.replaceChildren(container);
    return;
  }

  const resultsFragment = document.createDocumentFragment();
  for (const { forms, senses } of results) {
    const readings = forms
      .sort((a, b) => (b.common ? 1 : 0) - (a.common ? 1 : 0))
      .filter(({ kana }) => kana);

    // <Result>
    const resultContainer = document.createElement('div');
    resultContainer.style.display = 'flex';
    resultContainer.style.flexDirection = 'column';
    resultContainer.style.gap = '8px';
    resultContainer.style.alignItems = 'flex-start';

    const headWord = document.createElement('p');
    headWord.style.color = 'white';
    headWord.style.fontSize = '22px';
    headWord.style.margin = '0';
    headWord.textContent = forms
      .filter(({ kana }) => !kana)
      .map(({ common, form }) => (common ? form : `（${form}）`))
      .join('、');
    resultContainer.appendChild(headWord);

    const readingItem = document.createElement('p');
    readingItem.style.margin = '0';
    readingItem.style.color = 'white';
    readingItem.style.fontSize = defaultFontSize;
    readingItem.textContent = readings
      // Could represent uncommon using dice
      .map(({ common, form }) => (common ? form : `（${form}）`))
      .join('、');
    resultContainer.appendChild(readingItem);

    const senseList = document.createElement('div');
    senseList.style.display = 'flex';
    senseList.style.flexDirection = 'column';
    senseList.style.gap = '16px';
    for (const [i, { pos, gloss }] of senses.entries()) {
      const senseItem = document.createElement('div');
      senseItem.style.display = 'flex';
      senseItem.style.flexDirection = 'column';
      senseItem.style.alignItems = 'flex-start';
      senseItem.style.gap = '8px';
      senseItem.style.fontSize = defaultFontSize;

      const posList = document.createElement('ul');
      posList.style.display = 'flex';
      posList.style.flexDirection = 'row';
      posList.style.gap = '8px';
      posList.style.margin = '0';
      posList.style.padding = '0';
      posList.style.listStyle = 'none';
      for (const textContent of pos) {
        const posItem = document.createElement('li');
        posItem.style.color = 'white';
        posItem.style.borderWidth = '1px';
        posItem.style.borderStyle = 'solid';
        posItem.style.borderColor = 'grey';
        posItem.style.borderRadius = '4px';
        posItem.style.paddingLeft = '4px';
        posItem.style.paddingRight = '4px';
        posItem.style.fontSize = defaultFontSize;
        posItem.textContent = textContent;
        posList.appendChild(posItem);
      }
      senseItem.appendChild(posList);

      const glossItem = document.createElement('p');
      glossItem.style.margin = '0';
      glossItem.style.color = 'white';
      glossItem.style.fontSize = defaultFontSize;
      glossItem.textContent = `${i + 1}. ${gloss.join('; ')}`;
      senseItem.appendChild(glossItem);

      senseList.appendChild(senseItem);
    }

    resultContainer.appendChild(senseList);
    resultsFragment.appendChild(resultContainer);
  }

  container.appendChild(resultsFragment);
  popover.replaceChildren(container);
}

////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// Popover Layout /////////////////////////////////

/**
 * @param {import("./injected-javascript").CalculatePopoverLayoutParams} obj
 * @returns {import("./injected-javascript").PopoverLayout}
 */
function calculatePopoverLayout({
  permittedArrowDirections,
  safeAreaEdgeInsets,
  sourceRect,
  backdropHeight,
  backdropWidth,
  preferredHeight,
  preferredWidth,
  arrowBreadth,
  arrowLength,
  cornerWidth,
  borderRadius,
}) {
  log('backdrop:', { width: backdropWidth, height: backdropHeight });
  // Note: it is possible for backdrop size to briefly be (0, 0), so cater accordingly.

  /*
   * Clip off any parts of the source rect that exit the safe area.
   * Should the rect's x-pos or y-pos exits the safe area entirely, clip to the closest safe x-pos or y-pos.
   */
  const sourcePointClipped = {
    x: Math.min(
      Math.max(sourceRect.x, safeAreaEdgeInsets.left),
      Math.max(
        backdropWidth - safeAreaEdgeInsets.right,
        safeAreaEdgeInsets.left,
      ),
    ),
    y: Math.min(
      Math.max(sourceRect.y, safeAreaEdgeInsets.top),
      Math.max(
        backdropHeight - safeAreaEdgeInsets.bottom,
        safeAreaEdgeInsets.top,
      ),
    ),
  };

  const sourceRectClipped = {
    x: sourcePointClipped.x,
    y: sourcePointClipped.y,
    width: Math.max(
      Math.min(
        sourceRect.width - Math.abs(sourcePointClipped.x - sourceRect.x),
        backdropWidth - safeAreaEdgeInsets.left - safeAreaEdgeInsets.right,
      ),
      0,
    ),
    height: Math.max(
      Math.min(
        sourceRect.height - Math.abs(sourcePointClipped.y - sourceRect.y),
        backdropHeight - safeAreaEdgeInsets.top - safeAreaEdgeInsets.bottom,
      ),
      0,
    ),
  };

  log('sourceRectClipped:', sourceRectClipped);

  const sourceRectClippedMidpoint = {
    x: sourcePointClipped.x + sourceRectClipped.width / 2,
    y: sourcePointClipped.y + sourceRectClipped.height / 2,
  };

  /** @type {import("./injected-javascript").CalculatePopoverLayoutForArrowDirectionParams} */
  const params = {
    sourceRectClippedMidpoint,
    backdropWidth,
    safeAreaEdgeInsets,
    sourceRectClipped,
    backdropHeight,
    preferredHeight,
    preferredWidth,
    arrowBreadth,
    arrowLength,
    cornerWidth,
    borderRadius,
  };

  const permutations = {
    down: calculatePopoverLayoutForArrowDirectionDown(params),
    up: calculatePopoverLayoutForArrowDirectionUp(params),
    left: calculatePopoverLayoutForArrowDirectionLeft(params),
    right: calculatePopoverLayoutForArrowDirectionRight(params),
  };

  const layouts = [];
  for (let i = 0; i < permittedArrowDirections.length; i++) {
    const permittedDirection = permittedArrowDirections[i];

    /** @type {import("./injected-javascript").PopoverLayout | null} */
    let layout = null;
    switch (permittedDirection) {
      case PopoverArrowDirection.down:
        layout = permutations.down;
        break;
      case PopoverArrowDirection.up:
        layout = permutations.up;
        break;
      case PopoverArrowDirection.left:
        layout = permutations.left;
        break;
      case PopoverArrowDirection.right:
        layout = permutations.right;
        break;
    }
    if (layout === null) {
      continue;
    }
    if (
      layout.popover.height === preferredHeight &&
      layout.popover.width === preferredWidth
    ) {
      // First layout in priority order to satisfy constraints completely, so can bail out.
      return layout;
    }
    layouts.push(layout);
  }

  /* Note that Array.prototype.sort() mutates the array itself. */
  layouts.sort(sortLayoutsByArea);

  if (layouts.length !== 0) {
    return layouts[0];
  }

  /* Now we fall back to non-preferred directions. This might be undesirable, but likely better than showing nothing at all. */
  const nonPreferredLayouts = Object.keys(permutations)
    .map(directionName => permutations[directionName])
    .filter(layout => layout !== null)
    .sort(sortLayoutsByArea);

  if (nonPreferredLayouts.length > 0) {
    return nonPreferredLayouts[0];
  }

  return calculatePopoverLayoutForArrowDirectionNone(params);
}

/**
 * @param {import("./injected-javascript").PopoverLayout} a
 * @param {import("./injected-javascript").PopoverLayout} b
 */
function sortLayoutsByArea(a, b) {
  /**
   * Sort in descending order of area, e.g. to produce: [123, 456]
   * If any two layouts are found to have exactly the same area, then they'll be left in-place (still in preference order).
   */
  return (
    b.popover.height * b.popover.width - a.popover.height * a.popover.width
  );
}

/**
 * @param {import("./injected-javascript").CalculatePopoverLayoutForArrowDirectionParams} obj
 * @returns {import("./injected-javascript").PopoverLayout | null}
 */
function calculatePopoverLayoutForArrowDirectionDown({
  sourceRectClippedMidpoint,
  backdropWidth,
  safeAreaEdgeInsets,
  sourceRectClipped,
  backdropHeight,

  preferredWidth,
  preferredHeight,
  arrowBreadth,
  arrowLength,
  cornerWidth,
  borderRadius,
}) {
  const arrowPoint = {
    x: Math.max(
      Math.min(
        sourceRectClippedMidpoint.x - arrowBreadth / 2,
        backdropWidth - safeAreaEdgeInsets.right - arrowBreadth,
      ),
      safeAreaEdgeInsets.left,
    ),
    y: Math.max(
      Math.min(
        sourceRectClipped.y - arrowLength,
        backdropHeight - safeAreaEdgeInsets.bottom - arrowLength,
      ),
      safeAreaEdgeInsets.top,
    ),
  };

  const preferredX = sourceRectClippedMidpoint.x - preferredWidth / 2;
  const preferredY = arrowPoint.y - preferredHeight;

  const popoverOrigin = {
    x: Math.max(
      preferredX + preferredWidth <= backdropWidth - safeAreaEdgeInsets.right
        ? preferredX
        : backdropWidth - safeAreaEdgeInsets.right - preferredWidth,
      safeAreaEdgeInsets.left,
    ),
    y: Math.max(preferredY, safeAreaEdgeInsets.top),
  };

  const popoverSize = {
    width: Math.min(
      backdropWidth - popoverOrigin.x - safeAreaEdgeInsets.right,
      preferredWidth,
    ),
    height: Math.min(arrowPoint.y - safeAreaEdgeInsets.top, preferredHeight),
  };

  const borderBottomLeftRadius =
    arrowPoint.x <= popoverOrigin.x + cornerWidth ? 0 : borderRadius;
  const borderBottomRightRadius =
    arrowPoint.x >= popoverOrigin.x + popoverSize.width - cornerWidth
      ? 0
      : borderRadius;

  return {
    arrow: {
      direction: 'down',
      ...arrowPoint,
      width: arrowBreadth,
      height: arrowLength,
    },
    popover: {
      ...popoverOrigin,
      ...popoverSize,
      borderRadii: {
        borderTopRightRadius: borderRadius,
        borderTopLeftRadius: borderRadius,
        borderBottomLeftRadius,
        borderBottomRightRadius,
      },
    },
  };
}

/**
 * @param {import("./injected-javascript").CalculatePopoverLayoutForArrowDirectionParams} obj
 * @returns {import("./injected-javascript").PopoverLayout | null}
 */
function calculatePopoverLayoutForArrowDirectionUp({
  sourceRectClippedMidpoint,
  backdropWidth,
  safeAreaEdgeInsets,
  sourceRectClipped,
  backdropHeight,

  preferredWidth,
  preferredHeight,
  arrowBreadth,
  arrowLength,
  cornerWidth,
  borderRadius,
}) {
  const arrowPoint = {
    x: Math.max(
      Math.min(
        sourceRectClippedMidpoint.x - arrowBreadth / 2,
        backdropWidth - safeAreaEdgeInsets.right - arrowBreadth,
      ),
      safeAreaEdgeInsets.left,
    ),
    y: Math.max(
      Math.min(
        sourceRectClipped.y + sourceRectClipped.height,
        backdropHeight - safeAreaEdgeInsets.bottom - arrowLength,
      ),
      safeAreaEdgeInsets.top,
    ),
  };

  const preferredX = sourceRectClippedMidpoint.x - preferredWidth / 2;
  const preferredY = arrowPoint.y + arrowLength;

  const popoverOrigin = {
    x: Math.max(
      preferredX + preferredWidth <= backdropWidth - safeAreaEdgeInsets.right
        ? preferredX
        : backdropWidth - safeAreaEdgeInsets.right - preferredWidth,
      safeAreaEdgeInsets.left,
    ),
    y: Math.min(preferredY, backdropHeight - safeAreaEdgeInsets.bottom),
  };

  const popoverSize = {
    width: Math.min(
      backdropWidth - popoverOrigin.x - safeAreaEdgeInsets.right,
      preferredWidth,
    ),
    height: Math.min(
      backdropHeight - safeAreaEdgeInsets.bottom - preferredY,
      preferredHeight,
    ),
  };

  const borderTopLeftRadius =
    arrowPoint.x <= popoverOrigin.x + cornerWidth ? 0 : borderRadius;
  const borderTopRightRadius =
    arrowPoint.x >= popoverOrigin.x + popoverSize.width - cornerWidth
      ? 0
      : borderRadius;

  return {
    arrow: {
      direction: 'up',
      ...arrowPoint,
      width: arrowBreadth,
      height: arrowLength,
    },
    popover: {
      ...popoverOrigin,
      ...popoverSize,
      borderRadii: {
        borderTopRightRadius,
        borderTopLeftRadius,
        borderBottomLeftRadius: borderRadius,
        borderBottomRightRadius: borderRadius,
      },
    },
  };
}

/**
 * @param {import("./injected-javascript").CalculatePopoverLayoutForArrowDirectionParams} obj
 * @returns {import("./injected-javascript").PopoverLayout | null}
 */
function calculatePopoverLayoutForArrowDirectionLeft({
  sourceRectClippedMidpoint,
  backdropWidth,
  safeAreaEdgeInsets,
  sourceRectClipped,
  backdropHeight,

  preferredWidth,
  preferredHeight,
  arrowBreadth,
  arrowLength,
  cornerWidth,
  borderRadius,
}) {
  const arrowPoint = {
    x: Math.max(
      Math.min(
        sourceRectClipped.x + sourceRectClipped.width,
        backdropWidth - safeAreaEdgeInsets.right - arrowLength,
      ),
      safeAreaEdgeInsets.left,
    ),
    y: Math.max(
      Math.min(
        sourceRectClippedMidpoint.y - arrowBreadth / 2,
        backdropHeight - safeAreaEdgeInsets.bottom - arrowBreadth,
      ),
      safeAreaEdgeInsets.top,
    ),
  };

  const preferredX = arrowPoint.x + arrowLength;
  const preferredY = sourceRectClippedMidpoint.y - preferredHeight / 2;

  const popoverOrigin = {
    x: Math.max(
      Math.min(preferredX, backdropWidth - safeAreaEdgeInsets.right),
      arrowPoint.x + arrowLength,
    ),
    y: Math.max(
      preferredY + preferredHeight <= backdropHeight - safeAreaEdgeInsets.bottom
        ? preferredY
        : backdropHeight - safeAreaEdgeInsets.bottom - preferredHeight,
      safeAreaEdgeInsets.top,
    ),
  };

  const popoverSize = {
    width: Math.min(
      backdropWidth - popoverOrigin.x - safeAreaEdgeInsets.right,
      preferredWidth,
    ),
    height: Math.min(
      backdropHeight - safeAreaEdgeInsets.bottom - safeAreaEdgeInsets.top,
      preferredHeight,
    ),
  };

  const borderTopLeftRadius =
    arrowPoint.y <= popoverOrigin.y + cornerWidth ? 0 : borderRadius;
  const borderBottomLeftRadius =
    arrowPoint.y >= popoverOrigin.y + popoverSize.height - cornerWidth
      ? 0
      : borderRadius;

  return {
    arrow: {
      direction: 'left',
      ...arrowPoint,
      width: arrowLength,
      height: arrowBreadth,
    },
    popover: {
      ...popoverOrigin,
      ...popoverSize,
      borderRadii: {
        borderTopRightRadius: borderRadius,
        borderTopLeftRadius,
        borderBottomLeftRadius,
        borderBottomRightRadius: borderRadius,
      },
    },
  };
}

/**
 * @param {import("./injected-javascript").CalculatePopoverLayoutForArrowDirectionParams} obj
 * @returns {import("./injected-javascript").PopoverLayout | null}
 */
function calculatePopoverLayoutForArrowDirectionRight({
  sourceRectClippedMidpoint,
  backdropWidth,
  safeAreaEdgeInsets,
  sourceRectClipped,
  backdropHeight,

  preferredWidth,
  preferredHeight,
  arrowBreadth,
  arrowLength,
  cornerWidth,
  borderRadius,
}) {
  const arrowPoint = {
    x: Math.min(
      Math.max(safeAreaEdgeInsets.left, sourceRectClipped.x - arrowLength),
      backdropWidth - safeAreaEdgeInsets.right - arrowLength,
    ),
    y: Math.max(
      Math.min(
        sourceRectClippedMidpoint.y - arrowBreadth / 2,
        backdropHeight - safeAreaEdgeInsets.bottom - arrowBreadth,
      ),
      safeAreaEdgeInsets.top,
    ),
  };

  const preferredX = arrowPoint.x - preferredWidth;
  const preferredY = sourceRectClippedMidpoint.y - preferredHeight / 2;

  log('[DEBUG] safeAreaEdgeInsets', safeAreaEdgeInsets);

  const popoverOrigin = {
    x: Math.min(Math.max(safeAreaEdgeInsets.left, preferredX), arrowPoint.x),
    y: Math.max(
      preferredY + preferredHeight <= backdropHeight - safeAreaEdgeInsets.bottom
        ? preferredY
        : backdropHeight - safeAreaEdgeInsets.bottom - preferredHeight,
      safeAreaEdgeInsets.top,
    ),
  };

  const popoverSize = {
    width: Math.min(
      arrowPoint.x - safeAreaEdgeInsets.left,
      backdropWidth - popoverOrigin.x - safeAreaEdgeInsets.right,
      preferredWidth,
    ),
    height: Math.min(
      backdropHeight - safeAreaEdgeInsets.bottom - safeAreaEdgeInsets.top,
      preferredHeight,
    ),
  };

  const borderTopRightRadius =
    arrowPoint.y <= popoverOrigin.y + cornerWidth ? 0 : borderRadius;
  const borderBottomRightRadius =
    arrowPoint.y >= popoverOrigin.y + popoverSize.height - cornerWidth
      ? 0
      : borderRadius;

  return {
    arrow: {
      direction: 'right',
      ...arrowPoint,
      width: arrowLength,
      height: arrowBreadth,
    },
    popover: {
      ...popoverOrigin,
      ...popoverSize,
      borderRadii: {
        borderTopRightRadius,
        borderTopLeftRadius: borderRadius,
        borderBottomLeftRadius: borderRadius,
        borderBottomRightRadius,
      },
    },
  };
}

/**
 * @param {import("./injected-javascript").CalculatePopoverLayoutForArrowDirectionParams} obj
 * @returns {import("./injected-javascript").PopoverLayout}
 */
function calculatePopoverLayoutForArrowDirectionNone({
  sourceRectClippedMidpoint,
  backdropWidth,
  safeAreaEdgeInsets,
  backdropHeight,

  preferredWidth,
  preferredHeight,
  borderRadius,
}) {
  const arrowPoint = {
    x: 0,
    y: 0,
  };

  const preferredX = sourceRectClippedMidpoint.x - preferredWidth / 2;
  const preferredY = sourceRectClippedMidpoint.y - preferredHeight / 2;

  log('[DEBUG] safeAreaEdgeInsets', safeAreaEdgeInsets);

  const popoverOrigin = {
    x: Math.min(
      Math.max(
        preferredX + preferredWidth <= backdropWidth - safeAreaEdgeInsets.right
          ? preferredX
          : backdropWidth - safeAreaEdgeInsets.right - preferredWidth,
        safeAreaEdgeInsets.left,
      ),
      backdropWidth - safeAreaEdgeInsets.right,
    ),
    y: Math.min(
      Math.max(
        preferredY + preferredHeight <=
          backdropHeight - safeAreaEdgeInsets.bottom
          ? preferredY
          : backdropHeight - safeAreaEdgeInsets.bottom - preferredHeight,
        safeAreaEdgeInsets.top,
      ),
      backdropHeight - safeAreaEdgeInsets.top,
    ),
  };

  const popoverSize = {
    width: Math.min(
      backdropWidth - safeAreaEdgeInsets.right - popoverOrigin.x,
      preferredWidth,
    ),
    height: Math.min(
      backdropHeight - safeAreaEdgeInsets.bottom - popoverOrigin.y,
      preferredHeight,
    ),
  };

  return {
    arrow: {
      direction: 'none',
      ...arrowPoint,
      width: 0,
      height: 0,
    },
    popover: {
      ...popoverOrigin,
      ...popoverSize,
      borderRadii: {
        borderTopRightRadius: borderRadius,
        borderTopLeftRadius: borderRadius,
        borderBottomLeftRadius: borderRadius,
        borderBottomRightRadius: borderRadius,
      },
    },
  };
}

/** @type {{ up: 0, down: 1, left: 2, right: 3}} */
const PopoverArrowDirection = {
  up: 0,
  down: 1,
  left: 2,
  right: 3,
};

/////////////////////////////// Popover Layout /////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

/**
 * Wraps any direct bare text node children in a `<ruby>` with `<rb>`:
 *
 * ```diff
 * - <ruby>明日<rt>あした</rt></ruby>
 * + <ruby><rb>明日</rb><rt>あした</rt></ruby>
 * ```
 *
 * @param root {Element}
 */
function wrapRubyBaseTextsWithRb(root) {
  for (const ruby of root.querySelectorAll('ruby')) {
    for (const childNode of ruby.childNodes) {
      if (childNode.nodeName !== '#text') {
        continue;
      }
      const rb = document.createElement('rb');
      ruby.replaceChild(rb, childNode);
      rb.appendChild(childNode);
    }
  }
}

/**
 * Prepend a prelude and append a postlude into the <body>.
 */
function insertNavigationButtons(body) {
  // TODO: style Previous & Next as primary, and the Jump buttons as secondary.
  const commonStyles =
    'display: flex; justify-content: center; align-items: center; column-gap: 8px;';

  const prelude = `
<div id="paranovel-prelude" style="${commonStyles} padding-block-end: 16px;">
  <button id="paranovel-previous" type="button" style="writing-mode: horizontal-tb;">Previous</button>
  <button id="paranovel-end" type="button" style="writing-mode: horizontal-tb;">Jump to end</button>
</div>
  `.trim();

  const postlude = `
<div id="paranovel-postlude" style="${commonStyles} padding-block-start: 16px;">
  <button id="paranovel-start" type="button" style="writing-mode: horizontal-tb;">Return to start</button>
  <button id="paranovel-next" type="button" style="writing-mode: horizontal-tb;">Next</button>
</div>
  `.trim();

  for (const html of [postlude, prelude]) {
    const template = document.createElement('template');
    template.innerHTML = html;
    const dom = template.content.firstChild;

    switch (dom.id) {
      case 'paranovel-prelude': {
        const prev = dom.querySelector('#paranovel-previous');
        prev.onclick = event => {
          window.ReactNativeWebView.postMessage(
            JSON.stringify({
              type: 'navigation-request',
              value: 'prev',
              currentHref: location.href,
            }),
          );
        };

        const end = dom.querySelector('#paranovel-end');
        end.onclick = event => {
          document.body.scrollIntoView({
            block: 'end',
            inline: 'end',
            behavior: 'instant',
          });
        };

        body.prepend(dom);
        break;
      }
      case 'paranovel-postlude': {
        const next = dom.querySelector('#paranovel-next');
        next.onclick = event => {
          window.ReactNativeWebView.postMessage(
            JSON.stringify({
              type: 'navigation-request',
              value: 'next',
              currentHref: location.href,
            }),
          );
        };

        const start = dom.querySelector('#paranovel-start');
        start.onclick = event => {
          document.body.scrollIntoView({
            block: 'start',
            inline: 'start',
            behavior: 'instant',
          });
        };

        body.append(dom);
        break;
      }
    }
  }
}

function log(message) {
  window.ReactNativeWebView.postMessage(
    JSON.stringify({ type: 'log', message }),
  );
}

/**
 * @param {MouseEvent} event
 */
async function onClickDocument(event) {
  const { x, y } = event;

  const caretRange = document.caretRangeFromPoint(x, y);
  if (!caretRange) {
    log('❌ no caret range');
    return;
  }

  const surroundingText = getSurroundingText(caretRange);
  if (!surroundingText) {
    log('❌ no surrounding text');
    return;
  }
  console.log(surroundingText);
  const {
    blockBaseText,
    closestBlock,
    offsetOfTargetBaseTextIntoBlockBaseText,
    targetNode,
  } = surroundingText;

  __paranovelState.wordHighlight.clear();

  const id = __paranovelState.tokenizationPromiseCount++;

  let response;
  try {
    response = await new Promise((resolve, reject) => {
      __paranovelState.tokenizationPromiseHandlers[id] = { resolve, reject };

      // Promise is settled by onNovelViewMessage calling resolve/reject
      window.ReactNativeWebView.postMessage(
        JSON.stringify({
          type: 'tokenize',
          id,
          blockBaseText,
          offset: offsetOfTargetBaseTextIntoBlockBaseText,
        }),
      );
    });
  } catch (error) {
    console.error('Tokenize Promise rejected with error', error);
    log(
      `❌ Tokenize Promise rejected${
        error instanceof Error ? ` with error: "${error.message}"` : '.'
      }`,
    );
  } finally {
    delete __paranovelState.tokenizationPromiseHandlers[id];
  }

  const {
    dictionaryForm,
    tokenLength,
    offsetOfTargetTokenIntoBlockBaseText,
    offsetOfTargetCharacterIntoBlockBaseText,
  } = response;
  log(
    `📖 dictionaryForm: "${dictionaryForm}"; tokenOffset: ${offsetOfTargetTokenIntoBlockBaseText}, characterOffset: ${offsetOfTargetCharacterIntoBlockBaseText}; length: ${tokenLength}`,
  );

  const tokenRange = getRangeFromOffsetIntoBlockBaseText({
    blockElement: closestBlock,
    blockBaseText,
    startOffset: offsetOfTargetTokenIntoBlockBaseText,
    endOffset: offsetOfTargetTokenIntoBlockBaseText + tokenLength,
  });
  if (!tokenRange) {
    return;
  }

  // If we're inside a base text of a <ruby> (whether a text node or an <rb>),
  // and the selection range terminates at the end of that base text, then
  // search for the matching <rt> and extend the highlight to include that.
  const { endContainer, endOffset } = tokenRange;
  if (
    (endContainer instanceof CharacterData &&
      endOffset === endContainer.data.length) ||
    endOffset === endContainer.childNodes.length
  ) {
    const endContainerElement =
      endContainer instanceof Element
        ? endContainer
        : endContainer.parentElement;
    const endContainerRuby = endContainerElement?.closest('ruby');
    if (endContainerRuby) {
      /** @type {HTMLElement | undefined} */
      let correspondingRt;
      for (const node of traverseFollowingText(
        endContainerElement,
        'next',
        endContainerRuby,
      )) {
        if (node.nodeName.toUpperCase() === 'RT') {
          correspondingRt = node;
          break;
        }
      }
      if (correspondingRt) {
        tokenRange.setEnd(correspondingRt, correspondingRt.childNodes.length);
      }
    }
  }

  __paranovelState.wordHighlight.add(tokenRange);
  const sourceRect = tokenRange.getBoundingClientRect();
  const endContainerElement =
    tokenRange.endContainer instanceof Element
      ? tokenRange.endContainer
      : tokenRange.endContainer.parentElement;
  const writingMode =
    endContainerElement?.computedStyleMap().get('writing-mode') ??
    'horizontal-tb';

  log(
    `🔎 Looking up term "${dictionaryForm}" with sourceRect ${JSON.stringify(
      sourceRect.toJSON(),
    )} and writingMode "${writingMode}"`,
  );
  lookUpTerm({ dictionaryForm, sourceRect });
}

/**
 *
 * @param {object} obj
 * @param {string} obj.dictionaryForm
 * @param {DOMRect} obj.sourceRect
 * @param {"horizontal-tb" | "vertical-rl" | "vertical-lr"} obj.writingMode
 */
async function lookUpTerm({ dictionaryForm, sourceRect, writingMode }) {
  const id = __paranovelState.tokenizationPromiseCount++;

  /** @type {string} */
  let response;
  try {
    response = await new Promise((resolve, reject) => {
      __paranovelState.tokenizationPromiseHandlers[id] = { resolve, reject };

      // Promise is settled by onNovelViewMessage calling resolve/reject
      window.ReactNativeWebView.postMessage(
        JSON.stringify({
          type: 'lookUpTerm',
          term: dictionaryForm,
        }),
      );
    });
  } catch (error) {
    console.error('lookUpTerm Promise rejected with error', error);
    log(
      `❌ lookUpTerm Promise rejected${
        error instanceof Error ? ` with error: "${error.message}"` : '.'
      }`,
    );
    return;
  } finally {
    delete __paranovelState.tokenizationPromiseHandlers[id];
  }

  updatePopover({
    sourceRect,
    results: response,
    display: 'block',
  });
}

function getRangeFromOffsetIntoBlockBaseText({
  blockElement,
  blockBaseText,
  startOffset,
  endOffset,
}) {
  if (!(blockElement instanceof HTMLElement)) {
    throw new TypeError('Expected blockElement to be an HTML Element.');
  }

  if (startOffset < 0 || startOffset > blockBaseText.length) {
    throw new DOMException(
      'The index is not in the allowed range.',
      'IndexSizeError',
    );
  }

  const rangeLength = endOffset - startOffset;

  let offset = 0;
  const range = document.createRange();
  let foundStartOffset = false;
  let prevNode = null;
  for (const node of traverseBaseText(blockElement)) {
    const actual = node.textContent;
    const expected = blockBaseText.slice(offset, offset + actual.length);
    if (actual !== expected) {
      throw new Error(
        'Expected to be able to reproduce the originally extracted base text when retraversing the same block.',
      );
    }

    // If the offsets lie within this node, set the range accordingly.
    //
    // When there are multiple possible solutions due to the range being on a
    // boundary between two nodes, prefer to keep the range as small as
    // possible.
    //
    // Note that we blindly assume a forward range (startOffset < endOffset).

    // For startOffset, prefer the following node (thus >)
    if (!foundStartOffset && offset + actual.length > startOffset) {
      const offsetWithinNode = startOffset - offset;
      range.setStart(node, offsetWithinNode);
      foundStartOffset = true;
    }

    // For endOffset, prefer the current node (thus >=)
    if (foundStartOffset && offset + actual.length >= endOffset) {
      const offsetWithinNode = endOffset - offset;
      range.setEnd(node, offsetWithinNode);
      return range;
    }

    offset += actual.length;
    prevNode = node;
  }

  return null;
}

function getSurroundingText(range) {
  const { startContainer: targetNode, startOffset: targetOffset } = range;
  if (!(targetNode instanceof Text)) {
    return;
  }

  const element = targetNode.parentElement;
  if (!element) {
    return;
  }

  const closestRuby = element.closest('ruby');
  const blockElementsSelector =
    'address,article,aside,blockquote,canvas,dd,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hr,li,main,nav,noscript,ol,p,pre,section,table,tfoot,ul,video';
  const closestBlock = element.closest(blockElementsSelector);

  let leadingBaseText = '';
  let targetBaseText = '';
  let trailingBaseText = '';
  for (const { baseTextContent, stage } of traverseBlock(targetNode)) {
    switch (stage) {
      case BlockTraversalStage.leading: {
        leadingBaseText = `${baseTextContent}${leadingBaseText}`;
        break;
      }
      case BlockTraversalStage.target: {
        targetBaseText = baseTextContent;
        break;
      }
      case BlockTraversalStage.trailing: {
        trailingBaseText = `${trailingBaseText}${baseTextContent}`;
        break;
      }
    }
  }

  const offsetOfTargetBaseTextIntoBlockBaseText =
    leadingBaseText.length + (closestRuby ? 0 : targetOffset);
  const blockBaseText = leadingBaseText + targetBaseText + trailingBaseText;

  return {
    leadingBaseText,
    targetNode,
    targetBaseText,
    targetBaseTextSliced: targetBaseText.slice(
      offsetOfTargetBaseTextIntoBlockBaseText,
    ),
    trailingBaseText,
    closestBlock,
    blockBaseText,
    offsetOfTargetBaseTextIntoBlockBaseText,
  };
}

function* traverseBlock(textNode) {
  if (!(textNode instanceof Text)) {
    return;
  }

  const element = textNode.parentElement;
  if (!element) {
    return;
  }

  const closestRuby = element.closest('ruby');
  const pivot = closestRuby ?? textNode;
  const blockElementsSelector =
    'address,article,aside,blockquote,canvas,dd,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hr,li,main,nav,noscript,ol,p,pre,section,table,tfoot,ul,video';
  const closestBlock = element.closest(blockElementsSelector);

  for (const node of traverseFollowingText(pivot, 'previous', closestBlock)) {
    const baseTextContent = getBaseTextContent(node);
    yield { baseTextContent, stage: BlockTraversalStage.leading };
  }

  const targetBaseText = getBaseTextContent(pivot);
  yield { baseTextContent: targetBaseText, stage: BlockTraversalStage.target };

  for (const node of traverseFollowingText(pivot, 'next', closestBlock)) {
    const baseTextContent = getBaseTextContent(node);
    yield { baseTextContent, stage: BlockTraversalStage.trailing };
  }
}

const BlockTraversalStage = {
  leading: 0,
  target: 1,
  trailing: 2,
};

function getFollowingText(
  node,
  direction,
  untilAncestor,
  blocklist = element => false,
) {
  let followingText = '';

  if (direction === 'next') {
    for (const node of traverseFollowingText(
      node,
      direction,
      untilAncestor,
      blocklist,
    )) {
      const baseTextContent = getBaseTextContent(node);
      followingText = `${followingText}${baseTextContent}`;
    }
  } else {
    for (const node of traverseFollowingText(
      node,
      direction,
      untilAncestor,
      blocklist,
    )) {
      const baseTextContent = getBaseTextContent(node);
      followingText = `${baseTextContent}${followingText}`;
    }
  }

  return followingText;
}

/**
 * @param {Node} node
 * @param {"prev" | "next"} direction
 * @param {Node} [untilAncestor]
 * @param {(element: Element) => boolean} blocklist
 */
function* traverseFollowingText(
  node,
  direction,
  untilAncestor,
  blocklist = element => false,
) {
  let parent = node.parentElement;
  let sibling = direction === 'next' ? node.nextSibling : node.previousSibling;
  while (true) {
    // If we've reached the end of the run, climb up to the parent and continue.
    while (!sibling) {
      if (!parent || parent === untilAncestor) {
        return;
      }

      sibling =
        direction === 'next' ? parent.nextSibling : parent.previousSibling;

      // If we've walked into a blocklisted sibling, consider it the end of the
      // line and climb up further.
      if (blocklist(sibling)) {
        sibling = null;
      }

      parent = parent.parentElement;
    }

    yield sibling;

    sibling =
      direction === 'next' ? sibling.nextSibling : sibling.previousSibling;
  }
}

function* traverseBaseText(node) {
  const treeWalker = document.createTreeWalker(
    node,
    // We need SHOW_ELEMENT to filter out all <rt> subtrees, while the payload
    // we're actually interested in is SHOW_TEXT.
    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT,
    node => {
      switch (node.nodeName) {
        // Element nodeNames are uppercase in HTML, yet lowercase in XHTML
        case 'rt':
        case 'RT':
          return NodeFilter.FILTER_REJECT;
        case '#text':
          return NodeFilter.FILTER_ACCEPT;
        default:
          return NodeFilter.FILTER_SKIP;
      }
    },
  );

  // Make the traversal inclusive of the target node.
  if (node.nodeName === '#text') {
    yield node;
  }

  let nextNode;
  while ((nextNode = treeWalker.nextNode())) {
    yield nextNode;
  }
}

// Warning: does not return empty strings if called directly on/inside <rt>/<rp>
function getBaseTextContent(node) {
  let baseTextContent = '';
  for (const textNode of traverseBaseText(node)) {
    baseTextContent = `${baseTextContent}${textNode.textContent}`;
  }
  return baseTextContent;
}

const __paranovelState = {
  wordHighlight: new Highlight(),
  tokenizationPromiseCount: 0,
  tokenizationPromiseHandlers: {},
};

CSS.highlights.set('word', __paranovelState.wordHighlight);

insertNavigationButtons(document.body);
document.addEventListener('click', onClickDocument);
