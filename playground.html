<!--?xml version='1.0' encoding='utf-8'?-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja">
  <head>
    <title>Paranovel playground</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, user-scalable=no" />
    <style>
      ::highlight(ruby-highlight) {
        color: black;
        background-color: yellow;
      }
    </style>
  </head>
  <body>
    <section>
      <h1>Ruby highlighting tests</h1>

      <h2>With &lt;rb&gt;</h2>

      <p id="test-a"
        >ここは<ruby><rb>東</rb><rt>とう</rt></ruby
        ><ruby><rb>京</rb><rt>きょう</rt></ruby
        >です。</p
      >
      <table>
        <thead>
          <tr style="text-align: center">
            <th></th>
            <th>Start</th>
            <th>End</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <th>Adjust</th>
            <td>
              <button
                onclick="adjustHighlight({ range: testARange, bound: 'start', direction: 'prev', root: document.querySelector('#test-a') }); updateLog()">
                ◀️
              </button>
              <button
                onclick="adjustHighlight({ range: testARange, bound: 'start', direction: 'next', root: document.querySelector('#test-a') }); updateLog()">
                ▶️
              </button>
            </td>
            <td>
              <button
                onclick="adjustHighlight({ range: testARange, bound: 'end', direction: 'prev', root: document.querySelector('#test-a') }); updateLog()">
                ◀️
              </button>
              <button
                onclick="adjustHighlight({ range: testARange, bound: 'end', direction: 'next', root: document.querySelector('#test-a') }); updateLog()">
                ▶️
              </button>
            </td>
          </tr>
          <tr id="test-a-offset">
            <th>Offset</th>
            <td>0</td>
            <td>0</td>
          </tr>
          <tr id="test-a-node">
            <th>Node</th>
            <td>0</td>
            <td>0</td>
          </tr>
        </tbody>
      </table>

      <script>
        const rubyHighlight = new Highlight();
        const testARange = new Range();
        const testAruby1 = document.querySelector('#test-a ruby');
        testARange.setStart(testAruby1, 0);
        testARange.setEnd(testAruby1, testAruby1.childNodes.length);
        rubyHighlight.add(testARange);
        CSS.highlights.set('ruby-highlight', rubyHighlight);
        updateLog();

        /**
         * @param obj {object}
         * @param obj.range {Range}
         * @param obj.bound {"start" | "end"}
         * @param obj.direction {"prev" | "next"}
         * @param [obj.root] {Node} An optional root to prevent extending the
         *        range to.
         */
        function adjustHighlight({ range, bound, direction, root }) {
          console.log({ range, bound, direction });

          const node =
            bound === 'start' ? range.startContainer : range.endContainer;
          const offset =
            bound === 'start' ? range.startOffset : range.endOffset;

          const newRange = stepSelection({ node, offset, direction });
          if (!newRange || (root && newRange.node === root)) {
            return;
          }

          switch (bound) {
            case 'start': {
              range.setStart(newRange.node, newRange.offset);
              return;
            }
            case 'end': {
              range.setEnd(newRange.node, newRange.offset);
              return;
            }
            default: {
              return;
            }
          }
        }

        /**
         * @param obj {object}
         * @param obj.node {Node | null}
         * @param obj.offset {number}
         * @param obj.direction {"prev" | "next"}
         */
        function stepSelection({ node, offset, direction }) {
          switch (direction) {
            case 'prev': {
              if (node instanceof CharacterData) {
                // Move along the CharacterData, or onto the previous sibling.
                return offset
                  ? { node, offset: offset - 1 }
                  : stepOntoPreviousSibling(node);
              }

              // If we're at the end of a node with children, dig into it.
              const lastChild = node.lastChild;
              if (offset === node.childNodes.length && lastChild) {
                return {
                  node: lastChild,
                  offset:
                    lastChild instanceof CharacterData
                      ? lastChild.data.length
                      : lastChild.childNodes.length,
                };
              }

              // Prefer to step onto the previous sibling rather than using
              // non-terminal offsets into a container node.
              return stepOntoPreviousSibling(node);
            }
            case 'next': {
              if (node instanceof CharacterData) {
                // Move along the CharacterData, or onto the next sibling.
                return offset < node.data.length
                  ? { node, offset: offset + 1 }
                  : stepOntoNextSibling(node);
              }

              // If we're at the start of a node with children, dig into it.
              const firstChild = node.firstChild;
              if (!offset && firstChild) {
                return { node: firstChild, offset: 0 };
              }

              // Prefer to step onto the next sibling rather than using
              // non-terminal offsets into a container node.
              return stepOntoNextSibling(node);
            }
            default: {
              throw new Error(`Unexpected case "${direction}".`);
            }
          }
        }

        /**
         * @param node {Node}
         */
        function stepOntoPreviousSibling(node) {
          // If there's a previous sibling, transfer to the end offset of it.
          const previousSibling = node.previousSibling;
          if (previousSibling) {
            if (previousSibling instanceof CharacterData) {
              return {
                node: previousSibling,
                offset: previousSibling.data.length,
              };
            }

            return {
              node: previousSibling,
              offset: previousSibling.childNodes.length,
            };
          }

          // This must be the first child in the container. Try transferring
          // onto the front of it.

          const parentElement = node.parentElement;
          if (!parentElement) {
            return null;
          }

          return { node: parentElement, offset: 0 };
        }

        /**
         * @param node {Node}
         */
        function stepOntoNextSibling(node) {
          // If there's a next sibling, transfer to the start offset of it.
          const nextSibling = node.nextSibling;
          if (nextSibling) {
            return { node: nextSibling, offset: 0 };
          }

          // This must be the final child in the container. Try transferring
          // onto the end of it.

          const parentElement = node.parentElement;
          if (!parentElement) {
            return null;
          }

          return {
            node: parentElement,
            offset: parentElement.childNodes.length,
          };
        }

        function updateLog() {
          const testAOffsetStart = document.querySelector(
            '#test-a-offset td:nth-of-type(1)',
          );
          const testAOffsetEnd = document.querySelector(
            '#test-a-offset td:nth-of-type(2)',
          );
          const testANodeStart = document.querySelector(
            '#test-a-node td:nth-of-type(1)',
          );
          const testANodeEnd = document.querySelector(
            '#test-a-node td:nth-of-type(2)',
          );

          const { startContainer, startOffset, endContainer, endOffset } =
            testARange;

          testAOffsetStart.textContent = startOffset;
          testAOffsetEnd.textContent = endOffset;
          testANodeStart.textContent = stringifyNode(startContainer);
          testANodeEnd.textContent = stringifyNode(endContainer);

          function stringifyNode(node) {
            if (node instanceof CharacterData) {
              return `${node.nodeName}:${node.textContent ?? ''}`;
            }

            if (node instanceof Element) {
              return `<${node.tagName.toLowerCase()}>`;
            }

            return node?.toString() ?? 'null';
          }
        }
      </script>

      <!--
        <h2>Without &lt;rb&gt;</h2>
        <p
          >ここは<ruby>東<rt>とう</rt></ruby
          ><ruby>京<rt>きょう</rt></ruby
          >です。</p
        >
      -->
    </section>
  </body>
</html>
