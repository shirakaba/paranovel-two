<!--?xml version='1.0' encoding='utf-8'?-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="ja" xml:lang="ja">
  <head>
    <title>Paranovel playground</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, user-scalable=no" />
    <style>
      ::highlight(ruby-highlight) {
        color: black;
        background-color: yellow;
      }
    </style>
  </head>
  <body>
    <section>
      <h1>Ruby highlighting tests</h1>

      <h2>With &lt;rb&gt;</h2>

      <p id="test-a"
        >ここは<ruby><rb>東</rb><rt>とう</rt></ruby
        ><ruby><rb>京</rb><rt>きょう</rt></ruby
        >です。</p
      >
      <table>
        <thead>
          <tr style="text-align: center">
            <th></th>
            <th>Start</th>
            <th>End</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <th>Adjust</th>
            <td>
              <button
                onclick="adjustHighlight({ range: testARange, bound: 'start', direction: 'prev', root: document.querySelector('#test-a') }); updateLog()">
                ◀️
              </button>
              <button
                onclick="adjustHighlight({ range: testARange, bound: 'start', direction: 'next', root: document.querySelector('#test-a') }); updateLog()">
                ▶️
              </button>
            </td>
            <td>
              <button
                onclick="adjustHighlight({ range: testARange, bound: 'end', direction: 'prev', root: document.querySelector('#test-a') }); updateLog()">
                ◀️
              </button>
              <button
                onclick="adjustHighlight({ range: testARange, bound: 'end', direction: 'next', root: document.querySelector('#test-a') }); updateLog()">
                ▶️
              </button>
            </td>
          </tr>
          <tr id="test-a-offset">
            <th>Offset</th>
            <td>0</td>
            <td>0</td>
          </tr>
          <tr id="test-a-node">
            <th>Node</th>
            <td>0</td>
            <td>0</td>
          </tr>
        </tbody>
      </table>

      <script>
        const rubyHighlight = new Highlight();
        const testARange = new Range();
        const testAruby1 = document.querySelector('#test-a ruby');
        testARange.setStart(testAruby1, 0);
        testARange.setEnd(testAruby1, testAruby1.childNodes.length);
        rubyHighlight.add(testARange);
        CSS.highlights.set('ruby-highlight', rubyHighlight);
        updateLog();

        /**
         * @param obj {object}
         * @param obj.range {Range}
         * @param obj.bound {"start" | "end"}
         * @param obj.direction {"prev" | "next"}
         * @param [obj.root] {Node} An optional root to prevent extending the
         *        range to.
         */
        function adjustHighlight({ range, bound, direction, root }) {
          console.log({ range, bound, direction });

          const node =
            bound === 'start' ? range.startContainer : range.endContainer;
          const offset =
            bound === 'start' ? range.startOffset : range.endOffset;

          const newRange = stepSelection({ node, offset, direction });
          if (!newRange || (root && newRange.node === root)) {
            return;
          }

          switch (bound) {
            case 'start': {
              range.setStart(newRange.node, newRange.offset);
              return;
            }
            case 'end': {
              range.setEnd(newRange.node, newRange.offset);
              return;
            }
            default: {
              return;
            }
          }
        }

        /**
         * @param obj {object}
         * @param obj.node {Node | null}
         * @param obj.offset {number}
         * @param obj.direction {"prev" | "next"}
         */
        function stepSelection({ node, offset, direction }) {
          if (node instanceof CharacterData) {
            return stepSelectionCharacterData({ node, offset, direction });
          }

          if (node instanceof Element) {
            return stepSelectionElement({ element: node, offset, direction });
          }

          return null;
        }

        /**
         * @param obj {object}
         * @param obj.element {Element | null}
         * @param obj.offset {number}
         * @param obj.direction {"prev" | "next"}
         */
        function stepSelectionElement({ element, offset, direction }) {
          switch (direction) {
            case 'prev': {
              if (offset === element.childNodes.length) {
                const lastChild = element.lastChild;
                return lastChild
                  ? {
                      node: lastChild,
                      offset:
                        lastChild instanceof CharacterData
                          ? lastChild.data.length
                          : lastChild.childNodes.length,
                    }
                  : stepOntoPreviousSibling(element);
              }

              return stepOntoPreviousSibling(element);
            }
            case 'next': {
              if (offset === 0) {
                const firstChild = element.firstChild;
                return firstChild
                  ? { node: firstChild, offset: 0 }
                  : stepOntoNextSibling(element);
              }

              if (offset === element.childNodes.length) {
                return stepOntoNextSibling(element);
              }

              // Warning: haven't thought too much about offsets in the middle
              // of an element.
              return { node: element, offset: offset + 1 };
            }
          }

          return null;
        }

        /**
         * @param obj {object}
         * @param obj.node {CharacterData | null}
         * @param obj.offset {number}
         * @param obj.direction {"prev" | "next"}
         */
        function stepSelectionCharacterData({ node, offset, direction }) {
          switch (direction) {
            case 'prev': {
              // If offset is non-zero, we can safely decrement.
              if (offset) {
                return { node, offset: offset - 1 };
              }

              // Otherwise, we'll have to try the previous sibling.

              return stepOntoPreviousSibling(node);
            }
            case 'next': {
              // If offset is within the text's length, we can safely increment.
              if (offset < node.data.length) {
                return { node, offset: offset + 1 };
              }

              // Otherwise, we'll have to try the next sibling.

              return stepOntoNextSibling(node);
            }
          }

          return null;
        }

        /**
         * @param node {Node}
         */
        function stepOntoPreviousSibling(node) {
          const previousSibling = node.previousSibling;
          if (previousSibling) {
            // In the unlikely event that there's a CharacterData beside this
            // CharacterData, transfer to the end of it.
            if (previousSibling instanceof CharacterData) {
              return {
                node: previousSibling,
                offset: previousSibling.data.length,
              };
            }

            // If there's a sibling Element, transfer to the end of it.
            if (previousSibling instanceof Element) {
              return {
                node: previousSibling,
                offset: previousSibling.childNodes.length,
              };
            }

            // Unexpected case.
            return null;
          }

          // This must be the first child in the container. Try transferring
          // onto the front of it.

          const parentElement = node.parentElement;
          if (!parentElement) {
            return null;
          }

          return { node: parentElement, offset: 0 };
        }

        /**
         * @param node {Node}
         */
        function stepOntoNextSibling(node) {
          const nextSibling = node.nextSibling;
          if (nextSibling) {
            // In the unlikely event that there's a CharacterData beside this
            // CharacterData, transfer to the start of it.
            if (nextSibling instanceof CharacterData) {
              return { node: nextSibling, offset: 0 };
            }

            // If there's a sibling Element, transfer to the start of it.
            if (nextSibling instanceof Element) {
              return {
                node: nextSibling,
                offset: 0,
              };
            }

            // Unexpected case.
            return null;
          }

          // This must be the final child in the container. Try transferring
          // onto the end of it.

          const parentElement = node.parentElement;
          if (!parentElement) {
            return null;
          }

          return {
            node: parentElement,
            offset: parentElement.childNodes.length,
          };
        }

        function updateLog() {
          const testAOffsetStart = document.querySelector(
            '#test-a-offset td:nth-of-type(1)',
          );
          const testAOffsetEnd = document.querySelector(
            '#test-a-offset td:nth-of-type(2)',
          );
          const testANodeStart = document.querySelector(
            '#test-a-node td:nth-of-type(1)',
          );
          const testANodeEnd = document.querySelector(
            '#test-a-node td:nth-of-type(2)',
          );

          const { startContainer, startOffset, endContainer, endOffset } =
            testARange;

          testAOffsetStart.textContent = startOffset;
          testAOffsetEnd.textContent = endOffset;
          testANodeStart.textContent = stringifyNode(startContainer);
          testANodeEnd.textContent = stringifyNode(endContainer);

          function stringifyNode(node) {
            if (node instanceof Element) {
              return `<${node.tagName.toLowerCase()}>`;
            }

            if (node instanceof Text) {
              return `#text:${node.textContent ?? ''}`;
            }

            return node?.toString() ?? 'null';
          }
        }
      </script>

      <!--
        <h2>Without &lt;rb&gt;</h2>
        <p
          >ここは<ruby>東<rt>とう</rt></ruby
          ><ruby>京<rt>きょう</rt></ruby
          >です。</p
        >
      -->
    </section>
  </body>
</html>
